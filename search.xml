<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Datapath synthesis in Verilog</title>
    <url>/2021/02/21/verilog-datapath-md/</url>
    <content><![CDATA[<h6 id="锁存器的综合："><a href="#锁存器的综合：" class="headerlink" title="锁存器的综合："></a>锁存器的综合：</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> latch (</span><br><span class="line">    <span class="keyword">output</span> q_out,</span><br><span class="line">    <span class="keyword">input</span> data_in, enable, rst_b</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">assign</span> q_out = !(rst_b == <span class="number">1&#x27;b0</span>) ? <span class="number">0</span>:enable ? data_in:q_out;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当一条带条件操作符的连续赋值语句出现反馈时，综合工具将判断出它具有一个锁存器的功能，并给出它的硬件实现。</li>
<li>在赋值表达式的右逻辑发生变化的所有情况下，必须给行为中包含的所有变量赋值，否则会产生不想要的锁存器。因此所有用以实现组合逻辑的电平敏感行为电路的输入信号都必须包含于事件控制表达式中</li>
<li>电平敏感周期型行为中，赋值语句的右表达式中任意信号都不再出现于其左表达式中 （如果想要生成组合逻辑电路）</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有意综合锁存器，注意非阻塞赋值&lt;= 的运用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综合成带反馈的多路复用器结构</span></span><br><span class="line"><span class="keyword">module</span> latch_if1 (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>: <span class="number">0</span>] data_out, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>: <span class="number">0</span>] data_in, <span class="keyword">input</span> latch_enable</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">always</span> @ (*)</span><br><span class="line">        <span class="keyword">if</span> (latch_enable) data_out &lt;= data_in; </span><br><span class="line">        <span class="keyword">else</span> data_out &lt;= data_out; </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 综合成硬件锁存器</span></span><br><span class="line"><span class="keyword">module</span> latch_if2 (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>: <span class="number">0</span>] data_out, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>: <span class="number">0</span>] data_in, <span class="keyword">input</span> latch_enable</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">always</span> @ (*)</span><br><span class="line">        <span class="keyword">if</span> (latch_enable) data_out &lt;= data_in; </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>In a level-sensitive cyclic behavior. If a case statement has a default assignment with feedback (i.e., the variable is explicitly assigned to itself), the synthesis tool will form a mux structure with feedback. </li>
<li>Likewise, if an if statement in a level-sensitive behavior assigns a variable to itself, the result will be a mux structure with feedback.</li>
<li>If the conditional operator is used in a continuous assignment, the result will be a mux with feedback. If it is used in a level-sensitive cyclic behavior, the result will be a hardware latch. </li>
<li>If the conditional operator is used in an edge-sensitive cyclic behavior, the result will be a register with a gated data path in a feedback configuration with the output of the register.</li>
</ul>
<h6 id="触发器的综合："><a href="#触发器的综合：" class="headerlink" title="触发器的综合："></a>触发器的综合：</h6><p>A register variable in an edge-sensitive behavior will be synthesized as a flip-flop</p>
<p>(1) A variable that is referenced within an edge-sensitive behavior before it is assigned value in the behavior will be synthesized as the output of a flip-flop.</p>
<p>(2) if it is referenced within the behavior before it is assigned value.</p>
<p>(3) if it is assigned value in only some of the branches of the activity within the behavior.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步复位D触发器</span></span><br><span class="line"><span class="keyword">module</span> asynch_df_behav (</span><br><span class="line">	<span class="keyword">input</span> data, set_b, rst_b, clk,</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> q, outputq_bar</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">negedge</span> set_b, <span class="keyword">negedge</span> rst_b) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst_b == <span class="number">1&#x27;b0</span>)q &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(set_b == <span class="number">1&#x27;b0</span>)q &lt;= <span class="number">1</span>; </span><br><span class="line">    	<span class="keyword">else</span> q &lt;= data; <span class="comment">// synchronized activity </span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>综合工具只支持全部为边缘敏感或全部为电平敏感的事件控制表达式</li>
<li>always中的语句块为顺序执行，并且反复无限的执行</li>
<li>Recall that an incomplete conditional statement (i.e., an if … else statement or a case statement) in a level-sensitive cyclic behavior will synthesize to a latch. However, if the behavior is edge-sensitive, these types of statements will not create latches, but they will synthesize logic that implements a “clock enable,” because the incompletestatements imply that the affected variables should not change under the conditions implied by the logic, even though the clock makes a transition.</li>
</ul>
<h6 id="比较器的综合-连续赋值与寄存器传输模型的比较-："><a href="#比较器的综合-连续赋值与寄存器传输模型的比较-：" class="headerlink" title="比较器的综合 (连续赋值与寄存器传输模型的比较)："></a>比较器的综合 (连续赋值与寄存器传输模型的比较)：</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> compare_32_CA #(<span class="keyword">parameter</span> word__size = <span class="number">32</span>)(</span><br><span class="line">    <span class="keyword">output</span> A_gt_B,A_lt_B,A_eq_B, </span><br><span class="line">    <span class="keyword">input</span> [word__size-<span class="number">1</span>:O] A, B</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">assign</span> A_gt_B = (A&gt; B);</span><br><span class="line">	<span class="keyword">assign</span> A_lt_B = (A&lt; B); </span><br><span class="line">    <span class="keyword">assign</span> A_eq_B = (A== B); </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>关键词<code>assign</code> 定义了连续赋值，将右边等式的布尔表达式与左边的变量联系起来</li>
<li>基于连续赋值的建模方式用于描述电平敏感的行为，连续赋值语句之间，基本门之间以及描述中的所有行为模块之间都是并行执行的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Comp_2_RTL (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> A_lt_B,A_gt_B,A_eq_B, </span><br><span class="line">    <span class="keyword">input</span> A1, A0, B1, B0</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always</span> @ (A0, A1, B0, B1) <span class="keyword">begin</span> </span><br><span class="line">        A_lt_B = (&#123;A1, A0&#125; &lt; &#123;B1, B0&#125;); </span><br><span class="line">        A_gt_B = (&#123;A1, A0&#125; &gt; &#123;B1, B0&#125;); </span><br><span class="line">        A_eq_B = (&#123;A1, A0&#125; == &#123;B1, B0&#125;); </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>无论数据通道的哪一位在任何时间发生变化，电平敏感的周期性行为都将不断的进行，不断更新它的输出</li>
<li>周期性行为的语句<code>顺序执行</code>，无限循环</li>
</ul>
<h6 id="移位寄存器的综合-阻塞与非阻塞赋值的区别-："><a href="#移位寄存器的综合-阻塞与非阻塞赋值的区别-：" class="headerlink" title="移位寄存器的综合 (阻塞与非阻塞赋值的区别)："></a>移位寄存器的综合 (阻塞与非阻塞赋值的区别)：</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> shiftreg_PA (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> A, </span><br><span class="line">    <span class="keyword">input</span> E, clk, rst</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">reg</span> B, C, D; </span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> rst) <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">if</span> (rst == <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> </span><br><span class="line">            A=<span class="number">0</span>; B=<span class="number">0</span>; C= <span class="number">0</span>; D= <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">            A=B; B= C; C= D; D= E; </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>阻塞赋值<code>=</code> ，进行过程赋值的语句必须在行为中的下一条语句执行之前完成执行过程（把结果写入寄存器中）。紧随其后的过程赋值语句被阻塞执行，直到正在执行的过程赋值语句完成执行任务时为止</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> shiftreg_nb_V05 (</span><br><span class="line">	<span class="keyword">output</span> <span class="keyword">reg</span> A,</span><br><span class="line">    <span class="keyword">input</span> E, clk, rst</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">reg</span> B,C, D; </span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> rst) <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">if</span>(rst== <span class="number">1&#x27;b1</span>) <span class="keyword">begin</span> A&lt;=<span class="number">0</span>; B&lt;=<span class="number">0</span>;C&lt;=<span class="number">0</span>; D&lt;= <span class="number">0</span>; <span class="keyword">end</span> </span><br><span class="line">    	<span class="keyword">else</span> <span class="keyword">begin</span> </span><br><span class="line">            A &lt;= B; <span class="comment">// D &lt;= E; </span></span><br><span class="line">            B &lt;= C; <span class="comment">// C &lt;= D; </span></span><br><span class="line">            C &lt;= D; <span class="comment">// B &lt;= C; </span></span><br><span class="line">            D &lt;= E; <span class="comment">// A &lt;= B; </span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>非阻塞赋值<code>&lt;=</code> , 非阻塞赋值语句可以并发的执行，语句在列表中的排列顺序对最终的结果没有影响，一般仿真器在给左边目标赋值之前要计算每一个右表达式的值</li>
<li>非阻塞赋值表达式的左变量必须为<code>reg</code>类型</li>
<li>边沿敏感（同步）操作尽量用非阻塞赋值来完成，组合逻辑尽量用阻塞赋值来描述</li>
</ul>
<h6 id="计数器的综合："><a href="#计数器的综合：" class="headerlink" title="计数器的综合："></a>计数器的综合：</h6><h6 id="移位寄存器的综合："><a href="#移位寄存器的综合：" class="headerlink" title="移位寄存器的综合："></a>移位寄存器的综合：</h6><h6 id="寄存器的综合："><a href="#寄存器的综合：" class="headerlink" title="寄存器的综合："></a>寄存器的综合：</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Register_File #(<span class="keyword">parameter</span> word_size = <span class="number">32</span>, addr_size =<span class="number">5</span>)(</span><br><span class="line">    <span class="keyword">output</span> [word_size-<span class="number">1</span>: <span class="number">0</span>] Data_Out_1, Data_Out_2, </span><br><span class="line">	<span class="keyword">input</span> [word_size-<span class="number">1</span>:<span class="number">0</span>] Data_in, </span><br><span class="line">	<span class="keyword">input</span> [addr_size-<span class="number">1</span>:<span class="number">0</span>] Read_Addr_1, Read_Addr_2, Write_Addr, </span><br><span class="line">	<span class="keyword">input</span> Write_Enable, Clock</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">reg</span> [word_size-<span class="number">1</span>:<span class="number">0</span>] Reg_File [<span class="number">31</span>:<span class="number">0</span>]; <span class="comment">// 32bit x32 word memory declaration </span></span><br><span class="line">	<span class="keyword">assign</span> Data_Out_1 = Reg_File[Read_Addr_1];</span><br><span class="line">	<span class="keyword">assign</span> Data_Out_2 = Reg_File[Read_Addr_2];</span><br><span class="line">	<span class="keyword">always</span> @ (<span class="keyword">posedge</span> Clock) <span class="keyword">begin</span> </span><br><span class="line">        <span class="keyword">if</span> (Write_Enable == <span class="number">1&#x27;b1</span>) Reg_File[Write_Addr] &lt;= Data_in; </span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>



<h6 id="组合逻辑的综合："><a href="#组合逻辑的综合：" class="headerlink" title="组合逻辑的综合："></a>组合逻辑的综合：</h6><ul>
<li>结构化的原语网表</li>
<li>一系列连续赋值语句</li>
<li>电平敏感的周期性行为 （内部无反馈并且没有锁存器）</li>
</ul>
<h6 id="for的综合："><a href="#for的综合：" class="headerlink" title="for的综合："></a><code>for</code>的综合：</h6><ul>
<li>Provide a shorter way to express a series of statements</li>
<li>Loop index variables must be integer type</li>
<li>Step, start &amp; end value must be constant</li>
<li>In synthesis, for loops loops are “unrolled” , and then synthesized</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@( a <span class="keyword">or</span> b )</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">		<span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i=i+<span class="number">1</span> )</span><br><span class="line">			c[i] = a[i] &amp; b[i];</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Unrolled版本</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>@( a <span class="keyword">or</span> b )</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        c[<span class="number">0</span>] = a[<span class="number">0</span>] &amp; b[<span class="number">0</span>];</span><br><span class="line">        c[<span class="number">1</span>] = a[<span class="number">1</span>] &amp; b[<span class="number">1</span>];</span><br><span class="line">        c[<span class="number">2</span>] = a[<span class="number">2</span>] &amp; b[<span class="number">2</span>];</span><br><span class="line">        c[<span class="number">3</span>] = a[<span class="number">3</span>] &amp; b[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h6 id="Case和if的综合："><a href="#Case和if的综合：" class="headerlink" title="Case和if的综合："></a><code>Case</code>和<code>if</code>的综合：</h6><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优先级选择器</span></span><br><span class="line"><span class="keyword">module</span> mux_4pri (</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> y, </span><br><span class="line">    <span class="keyword">input</span> a, b, c, d, sel_a, sel_b, sel_c</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">always</span> @ (sel_a, sel_b, sel_c, a, b, c, d)</span><br><span class="line"><span class="comment">//  always @ (&quot;) Optional wildcard token for complete sensitivity list </span></span><br><span class="line">    <span class="keyword">if</span> (sel_a==<span class="number">1</span>) y = a; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sel_b==<span class="number">0</span>) y = b; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sel_c ==<span class="number">1</span>) y = c; </span><br><span class="line">                <span class="keyword">else</span> y = d; </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>case</code>和<code>if</code>语句一般被综合成组合电路</li>
<li><code>case</code>语句通常隐含的对首先解码的选项赋予较高优先权，而<code>if</code>语句则隐含指定第一个分支具有更高优先权。综合工具会先判断<code>case</code>中的分支选择是否互斥，如果互斥，综合工具认为它们具有相同的优先级，综合成为一个多路选择器，如何不互斥则综合为优先级结构</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> alu_with_z1 (</span><br><span class="line">    <span class="keyword">output</span> alu_out, </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>: <span class="number">0</span>] data_a, data_b, <span class="keyword">input</span> [<span class="number">2</span>: <span class="number">0</span>] opcode, <span class="keyword">input</span> enable</span><br><span class="line">); </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>: <span class="number">0</span>] alu_reg; </span><br><span class="line">    <span class="keyword">assign</span> alu_out = (enable == <span class="number">1</span>) ? alu_reg : <span class="number">4&#x27;bz</span>; </span><br><span class="line">    <span class="keyword">always</span> @ (opcode, data_a, data_b)</span><br><span class="line">        <span class="keyword">case</span> (opcode)</span><br><span class="line">            <span class="number">3&#x27;b001</span>: alu_reg = data_a |data_b;</span><br><span class="line">            <span class="number">3&#x27;b010</span>: alu_reg = data_a ^ data_b;</span><br><span class="line">            <span class="number">3&#x27;b110</span>: alu_reg = ~data_b; </span><br><span class="line">            <span class="keyword">default</span>: alu_reg = <span class="number">4&#x27;b0</span>; <span class="comment">// alu_with_z2 has default: alu_reg = 4&#x27;bx; </span></span><br><span class="line">        <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>

<ul>
<li>缺少默认赋值语句会使<code>寄存器变量</code>输出锁存，综合工具会自动生成锁存器 （在条件未定义时保持输出原值）</li>
<li>当对默认赋值语句没有限制时（e.g., 4’bx）综合工具将视为无关紧要条件，减少电路所需逻辑</li>
<li>如果一个条件操作符将<code>z</code>值放在电平敏感行为中连续赋值的右表达式中，那么该语句将会综合成通过组合逻辑驱动的一个三态器件中</li>
</ul>
]]></content>
      <categories>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>verilog</tag>
      </tags>
  </entry>
</search>
