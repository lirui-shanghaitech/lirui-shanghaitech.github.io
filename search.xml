<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Modulo Scheduling In HLS (Loop Pipeline Synthesize)</title>
    <url>/2021/03/28/modulo-scheduling/</url>
    <content><![CDATA[<h2 id="Modulo-Scheduling-In-HLS-Loop-Pipeline-synthesis"><a href="#Modulo-Scheduling-In-HLS-Loop-Pipeline-synthesis" class="headerlink" title="Modulo Scheduling In HLS (Loop Pipeline synthesis)"></a>Modulo Scheduling In HLS (Loop Pipeline synthesis)</h2><h3 id="Instruction-Scheduling-Introduction"><a href="#Instruction-Scheduling-Introduction" class="headerlink" title="Instruction Scheduling Introduction"></a>Instruction Scheduling Introduction</h3><p>Instruction Scheduling can be broken into three categories: <em>Local Scheduling, Global Scheduling, and Cyclic Scheduling</em>:</p>
<ul>
<li><strong>Local Scheduling</strong> handles single basic blocks which are regions of straight line code that have a single entry and exit (List scheduling).</li>
<li><strong>Global Scheduling</strong> can handle multiple basic blocks with acyclic control flow (Trace Scheduling, Superblock Scheduling, Hyperblock Scheduling).</li>
<li><strong>Cyclic Scheduling</strong> handles single or multiple basic blocks with cyclic control flow. (Modulo Scheduling)</li>
</ul>
<p>There exist many Global Scheduling algorithms that can also be used in cyclic scheduling</p>
<ul>
<li><strong>Trace Scheduling</strong> It identifies frequently executed traces in the program and treats the path as an extended basic block which is scheduled using a list scheduling approach.</li>
<li><strong>Superblock Scheduling</strong> Superblocks are a subset of traces which have a single entry and multiple exit attributes (therefore they are traces without side exits). List scheduling is typically used to schedule the superblock.</li>
<li><strong>Hyperblock Scheduling</strong> Excessive control flow can complicate scheduling, so this approach uses a technique called If-Conversion to remove conditional branches.</li>
</ul>
<span id="more"></span>

<h3 id="General-Steps-Of-Modulo-Scheduling"><a href="#General-Steps-Of-Modulo-Scheduling" class="headerlink" title="General Steps Of Modulo Scheduling"></a>General Steps Of Modulo Scheduling</h3><p>Modulo Scheduling is <em>traditionally restricted to single basic block loops without control flow</em>, which can limit the number of candidate loops. Global Software Pipelining techniques have emerged to exploit some of the opportunities for ILP in multiple basic block loops that frequently occur in computation intensive applications.</p>
<p><img src="/images/image-20210328124007797.png" alt="image-20210328124007797"></p>
<p>Using the DDG, the Minimum Initiation Interval (MII), which is the minimum amount of time between the start of successive iterations of a loop, is computed. Modulo Scheduling algorithms aim to create a schedule with an Initiation Interval (II) equal to MII, which is the smallest II possible and results in the most optimal schedule. The lower the II, the greater the parallelism.</p>
<img src="/images/image-20210328171553786.png" alt="image-20210328171553786" style="zoom:50%;" />


<p>Using the MII value as their initial II value, the algorithms attempt to schedule each instruction in the loop using some set of heuristics. If an optimal schedule can not be obtained, II is increased, and the algorithm attempts to compute the schedule again. This process is repeated until a schedule is obtained or the algorithm gives up. From this schedule, the loop is then reconstructed into a prologue, a kernel, and an epilogue. The prologue begins the first n iterations. After <strong>n ∗ II</strong> cycles, a steady state is achieved and a new iteration is initiated every II cycles. The epilogue finishes the last n iterations. Loops with long execution times will spend the majority of their time in the kernel.</p>
<h3 id="Main-Steps"><a href="#Main-Steps" class="headerlink" title="Main Steps"></a>Main Steps</h3><h4 id="Data-Dependency-Graph-construction"><a href="#Data-Dependency-Graph-construction" class="headerlink" title="Data Dependency Graph construction"></a>Data Dependency Graph construction</h4><p>There are three types of dependencies in the DDG:</p>
<ul>
<li><strong>True Dependence</strong>: If the first instruction writes to a value, and a second instruction reads the same value, there is a true dependence from the first instruction to the second.</li>
<li><strong>Anti Dependence</strong>: If the first instruction reads a value, and a second instruction writes a value, then there is an anti dependence from the first instruction to the second.</li>
<li><strong>Output Dependence</strong>: If two instructions both write to the same value, then there is an output dependence between them.</li>
</ul>
<p>Each dependence has a distance associated with it, called the iteration difference. If the distance is zero, this means the dependence is a loop-independent dependence, in other words a dependence within one iteration. If the distance is greater than zero, there is a dependence across iterations, a loop-carried dependence. <strong>The value of the distance for loop-carried dependences is one</strong> (a conservative guess), unless further analysis can prove the actual number of iterations between the instructions. The distance can also be calculated using SCEV and AA analysis, for details info, please refer to Chapter4.2 of this <a href="https://llvm.org/pubs/2005-06-17-LattnerMSThesis.pdf">artical</a></p>
<h4 id="Calculating-the-Minimum-Initiation-Interval"><a href="#Calculating-the-Minimum-Initiation-Interval" class="headerlink" title="Calculating the Minimum Initiation Interval"></a>Calculating the Minimum Initiation Interval</h4><h5 id="Resource-II-Heuritic-exact-method-is-NP-hard"><a href="#Resource-II-Heuritic-exact-method-is-NP-hard" class="headerlink" title="Resource II (Heuritic, exact method is NP-hard)"></a>Resource II (Heuritic, exact method is NP-hard)</h5><img src="/images/image-20210328144653002.png" alt="image-20210328144653002" style="zoom:50%;" />

<h5 id="Recurrence-II"><a href="#Recurrence-II" class="headerlink" title="Recurrence II"></a>Recurrence II</h5><p>Recurrences may be found in the the DDG if instructions have dependences across iterations of the loop. Memory operations (load/store) are most likely the cause of a recurrence in the DDG. Recurrences are also known as circuits or cycles.</p>
<img src="/images/image-20210328145300523.png" alt="image-20210328145300523" style="zoom:50%;" />

<p>In order to compute the Recurrence Minimum Initiation Interval (RecMII), all recurrences in the DDG must be found. the algorithm proposed by <a href="https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF">Donald Johnson</a> is used to find all elementary circuits in the DDG. If no vertex except the first and last appear twice, then a circuit is termed elementary (I found an excellent video about implementation and explanation of this <a href="https://www.youtube.com/watch?v=johyrWospv0">algorithm</a>).</p>
<h4 id="SDC-based-Scheduling"><a href="#SDC-based-Scheduling" class="headerlink" title="SDC-based Scheduling"></a>SDC-based Scheduling</h4><h5 id="Modeling-Loop-Carried-Dependence-with-SDC"><a href="#Modeling-Loop-Carried-Dependence-with-SDC" class="headerlink" title="Modeling Loop-Carried Dependence with SDC"></a>Modeling Loop-Carried Dependence with SDC</h5><img src="/images/image-20210328193951067.png" alt="image-20210328193951067" style="zoom:50%;" />

<p>This was just <code>end(u) - start(v) &lt;= II * dis(u,v)</code> where <code>end(u)</code> is the cycle time when the output of operation <code>u</code> is available, and <code>start(v)</code> is the starting cycle of operation <code>v</code>,  for the above example, <code>u</code> is <code>v5</code> and <code>v</code> is <code>v1</code> . Note that <code>Lat(u)</code> is counted by cycles not the real latency, for instance, if the add takes <code>2ns</code> to finish and the cycle time is <code>5ns</code> then, the <code>Lat(add) = 0</code>, where, if the add takes <code>6ns</code>,  the <code>Lat(add) = 1</code>.</p>
<h5 id="Inter-Iteration-Cycle-Time-Constraint-with-SDC"><a href="#Inter-Iteration-Cycle-Time-Constraint-with-SDC" class="headerlink" title="Inter-Iteration Cycle Time Constraint with SDC"></a>Inter-Iteration Cycle Time Constraint with SDC</h5><p>Loop pipelining exposes possibili- ties of chaining operations across iterations; namely, the result produced by an operation can be directly consumed in the same clock cycle by another operation that belongs to a later iteration. If such a path exists and involves one or mul- tiple inter-iteration dependences (i.e., back edges), we need to construct the following constraint to ensure that a register is inserted on this path to prevent the unfavorable cross- iteration chaining from causing a frequency violation.</p>
<img src="/images/image-20210328195012817.png" alt="image-20210328195012817" style="zoom:50%;" />

<p>The above constraint can also be rewrote to <code>s(v) + II*Dis(u,v) &gt; s(u) + Lat(u)</code>, note that, here we use <code>&gt;</code> instead of <code>&gt;=</code> since the <code>-1</code> is dropped.</p>
<h5 id="Resource-Constraint-with-Modulo-Reservation-Table-MRT"><a href="#Resource-Constraint-with-Modulo-Reservation-Table-MRT" class="headerlink" title="Resource Constraint with Modulo Reservation Table (MRT)"></a>Resource Constraint with Modulo Reservation Table (MRT)</h5><p>Given resource constraints, we keep track of available resources using a table, where each row tracks a resource and each column is an available time slot. When we schedule an operation at time t, we reserve a single time slot in column t mod II of the table and in the appropriate resource row. Consequently the table is called the modulo reservation table (MRT) and has II time slot columns.</p>
]]></content>
      <categories>
        <category>HLS</category>
      </categories>
      <tags>
        <tag>Modulo Scheduling</tag>
      </tags>
  </entry>
  <entry>
    <title>Lpsolve tutorial (Linear Programming Solver)</title>
    <url>/2021/03/23/lpsolve/</url>
    <content><![CDATA[<h2 id="Lpsolve-tutorial"><a href="#Lpsolve-tutorial" class="headerlink" title="Lpsolve tutorial"></a>Lpsolve tutorial</h2><h3 id="Problem-formulation"><a href="#Problem-formulation" class="headerlink" title="Problem formulation"></a>Problem formulation</h3><blockquote>
<p>Suppose a farmer has 75 acres on which to plant two crops: wheat and barley. To produce these crops, it costs the farmer (for seed, fertilizer, etc.) $120 per acre for the wheat and $210 per acre for the barley. The farmer has $15000 available for expenses. But after the harvest, the farmer must store the crops while awaiting favourable market conditions. The farmer has storage space for 4000 bushels. Each acre yields an average of 110 bushels of wheat or 30 bushels of barley. If the net profit per bushel of wheat (after all expenses have been subtracted) is $1.30 and for barley is $2.00, how should the farmer plant the 75 acres to maximize profit?</p>
</blockquote>
<p>Mathmatically, we can formulate this as :</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Maximize P <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1.30</span><span class="token punctuation">)</span>x <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">2.00</span><span class="token punctuation">)</span>y <span class="token operator">=</span> <span class="token number">143</span>x <span class="token operator">+</span> <span class="token number">60</span>y
s<span class="token punctuation">.</span>t<span class="token punctuation">.</span>            
				<span class="token number">120</span>x <span class="token operator">+</span> <span class="token number">210</span>y <span class="token operator">&lt;=</span> <span class="token number">15000</span>
                <span class="token number">110</span>x <span class="token operator">+</span> <span class="token number">30</span>y <span class="token operator">&lt;=</span> <span class="token number">4000</span>
                x <span class="token operator">+</span> y <span class="token operator">&lt;=</span> <span class="token number">75</span>
                x <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">>=</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<span id="more"></span>

<p>where  <code>x</code> denote the number of acres allotted to wheat and <code>y</code> the number of acres allotted to barley, the optimal solution of this problem is </p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">x <span class="token operator">=</span> <span class="token number">21.875</span>
y <span class="token operator">=</span> <span class="token number">75</span> <span class="token operator">-</span> <span class="token number">21.875</span> <span class="token operator">=</span> <span class="token number">53.125</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>How to solve this in LPSOLVE ?</p>
<h3 id="Construct-model-from-C-C"><a href="#Construct-model-from-C-C" class="headerlink" title="Construct model from C/C++"></a>Construct model from C/C++</h3><ol>
<li><h4 id="Setup-the-problem"><a href="#Setup-the-problem" class="headerlink" title="Setup the problem"></a>Setup the problem</h4></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">lprec <span class="token operator">*</span>lp <span class="token operator">=</span>  <span class="token function">make_lp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Ncol<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// there are two variables in the model, Ncol = 2</span>
<span class="token function">set_col_name</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"x"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	   <span class="token comment">// name our variables. Not required, but can be useful </span>
<span class="token function">set_col_name</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ol start="2">
<li><h4 id="Add-constraints-examples"><a href="#Add-constraints-examples" class="headerlink" title="Add constraints (examples)"></a>Add constraints (examples)</h4></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">set_add_rowmode</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// makes building the model faster if it is done rows by row</span>
REAL row<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">/* must be 1 more than number of columns ! */</span>
REAL sparserow<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* must be the number of non-zero values */</span>
<span class="token keyword">int</span> colno<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/* Create a new LP model */</span>
row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>
row<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">210</span><span class="token punctuation">;</span> <span class="token comment">/* also zero elements must be provided */</span>
<span class="token function">add_constraint</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> row<span class="token punctuation">,</span> LE<span class="token punctuation">,</span> <span class="token number">15000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* constructs the row: 120x + 210y &lt;= 15000 */</span>

colno<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> sparserow<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span> <span class="token comment">/* column 1 */</span>
colno<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> sparserow<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment">/* column 2 */</span>
<span class="token function">add_constraintex</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> sparserow<span class="token punctuation">,</span> colno<span class="token punctuation">,</span> LE<span class="token punctuation">,</span> <span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* constructs the row: 110x + 30y &lt;= 4000 */</span>
<span class="token function">set_add_rowmode</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// You can also set the row name to name the constraints</span>
<span class="token function">set_row_name</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"row1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">set_row_name</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"row2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><input disabled="" type="checkbox">  Note that for <strong>add_constraint</strong> (and <strong>add_constraintex</strong> when <em>colno</em> is NULL) element 0 of the array is not considered (i.e. ignored). Column 1 is element 1, column 2 is element 2, …, that is why row[1+2] must have <code>three</code> elements</p>
</li>
<li><p><input disabled="" type="checkbox">  add_constraintex has the possibility to specify only the non-zero elements. In that case <em>colno</em> specifies the column numbers of the non-zero elements. Both <em>row</em> and <em>colno</em> are then zero-based arrays. This will speed up building the model considerably if there are a lot of zero values. In most cases the matrix is sparse and has many zero value. Note that <strong>add_constraintex</strong> behaves the same as <strong>add_constraint</strong> when <em>colno</em> is NULL.</p>
</li>
<li><p><input disabled="" type="checkbox">  LE:  Less than or equal (&lt;=), EQ:  Equal (=), GE:  Greater than or equal (&gt;=)</p>
</li>
<li><p><input disabled="" type="checkbox">  Note that: <strong>ROW0</strong> is the objective function, so when index the constraints start from 1, for instance <code> set_mat(lp, 1, 1, 3.14);</code> set the first constaints to be <code>3.14x+210y &lt;= 15000</code>, also when you iterate through variables you must start with 1 (strange it not start with zero)</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>COL0 (Unsed)</th>
<th>COL1 (X)</th>
<th>COL2 (Y)</th>
</tr>
</thead>
<tbody><tr>
<td>ROW0 (Obj)</td>
<td>X</td>
<td>143</td>
<td>60</td>
</tr>
<tr>
<td>ROW1 (Cons1)</td>
<td>X</td>
<td>120</td>
<td>210</td>
</tr>
<tr>
<td>ROW2 (Cons2)</td>
<td>X</td>
<td>110</td>
<td>30</td>
</tr>
</tbody></table>
<ol start="3">
<li><h4 id="Set-objective"><a href="#Set-objective" class="headerlink" title="Set objective"></a>Set objective</h4></li>
</ol>
<p>There are four functions to set your objective function</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">set_obj_fn</span><span class="token punctuation">(</span>lprec <span class="token operator">*</span>lp<span class="token punctuation">,</span> REAL <span class="token operator">*</span>row<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">set_obj_fnex</span><span class="token punctuation">(</span>lprec <span class="token operator">*</span>lp<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">,</span> REAL <span class="token operator">*</span>row<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>colno<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">str_set_obj_fn</span><span class="token punctuation">(</span>lprec <span class="token operator">*</span>lp<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>row_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token function">set_obj</span><span class="token punctuation">(</span>lprec <span class="token operator">*</span>lp<span class="token punctuation">,</span> <span class="token keyword">int</span> column<span class="token punctuation">,</span> REAL value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>Note that it is advised to set the objective function before adding rows via <a href="http://lpsolve.sourceforge.net/5.5/add_constraint.htm">add_constraint, add_constraintex, str_add_constraint</a>. This especially for larger models. This will be much more performant than adding the objective function afterwards (Here, we did not use it in such way).</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">REAL row<span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* must be 1 more then number of columns ! */</span>
<span class="token comment">/* Create a new LP model */</span>
row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">143</span><span class="token punctuation">;</span>
row<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>
<span class="token function">set_obj_fn</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> row<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* constructs the obj: 143x + 60y */</span>

<span class="token comment">/* Another way using set_obj_fnex */</span>
REAL sparserow<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* must be the number of non-zero values */</span>
<span class="token keyword">int</span> colno<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
colno<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> sparserow<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">143</span><span class="token punctuation">;</span> <span class="token comment">/* column 1 */</span>
colno<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> sparserow<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span> <span class="token comment">/* column 2 */</span>
<span class="token function">set_obj_fnex</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> sparserow<span class="token punctuation">,</span> colno<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><input disabled="" type="checkbox">  Note that for <strong>set_obj_fn</strong> (and <strong>set_obj_fnex</strong> when <em>colno</em> is NULL) element 0 of the array is not considered (i.e. ignored). Column 1 is element 1, column 2 is element 2, …</p>
</li>
<li><p><strong>set_obj_fnex</strong> has the possibility to specify only the non-zero elements. In that case <em>colno</em> specifies the column numbers of the non-zero elements. This will speed up building the model considerably if there are a lot of zero values. In most cases the matrix is sparse and has many zero value. Thus it is almost always better to use <strong>set_obj_fnex</strong> instead of <strong>set_obj_fn</strong>. <strong>set_obj_fnex</strong> is always at least as performant as <strong>set_obj_fn</strong>. Note that unspecified values by <strong>set_obj_fnex</strong> are set to zero.</p>
</li>
<li><p><input disabled="" type="checkbox">  The <strong>set_obj</strong> function sets the objective value for the specified column. If multiple objective values must be set, it is more performant to use <strong>set_obj_fnex</strong>.</p>
</li>
</ul>
<ol start="4">
<li><h4 id="Solve-problem"><a href="#Solve-problem" class="headerlink" title="Solve problem"></a>Solve problem</h4></li>
</ol>
<p>First you need to tell lpsolve whether you want to maximize or minimize ojective function, the call <code>solve </code> function to solve it</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">set_maxim</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Just out of curioucity, now show the model in lp format on screen */</span>
<span class="token function">write_LP</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">/* I only want to see important messages on screen while solving */</span>
<span class="token function">set_verbose</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> IMPORTANT<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">/* Now let lpsolve calculate a solution */</span>
<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">solve</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>The solve will return integer values to indicate the state of solving process <code>OPTIMAL </code>, <code>SUBOPTIMAL </code>, <code>INFEASIBLE </code> …, you can use these values to judge whether lpsolve successfully solve the problem.</p>
<ol start="5">
<li><h4 id="Get-the-result"><a href="#Get-the-result" class="headerlink" title="Get the result"></a>Get the result</h4></li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Returns the value of the objective function. */</span>
REAL <span class="token function">get_objective</span><span class="token punctuation">(</span>lprec <span class="token operator">*</span>lp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Objective value: %f\n"</span><span class="token punctuation">,</span> <span class="token function">get_objective</span><span class="token punctuation">(</span>lp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* There are two ways to get final variable value */</span>
REAL var<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>ptr_var<span class="token punctuation">;</span>
<span class="token function">get_variables</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> var<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">get_ptr_variables</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr_var<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><input disabled="" type="checkbox"> The <strong>get_variables</strong>, <strong>get_ptr_variables</strong> functions retrieve the values of the variables. These values are only valid after a successful <a href="http://lpsolve.sourceforge.net/5.5/solve.htm">solve</a> or <a href="http://lpsolve.sourceforge.net/5.5/lag_solve.htm">lag_solve</a>. Function <strong>get_variables</strong> needs an array that is already dimensioned with <a href="http://lpsolve.sourceforge.net/5.5/get_Ncolumns.htm">get_Ncolumns</a> elements. <strong>get_ptr_variables</strong> returns a pointer to an array already dimensioned by lp_solve. Element 0 will contain the value of the first variable, element 1 of the second variable, …</li>
</ul>
<h4 id="IMPORTANT"><a href="#IMPORTANT" class="headerlink" title="IMPORTANT"></a>IMPORTANT</h4><p><strong>!!! The offical <a href="http://lpsolve.sourceforge.net/5.5/">lp_solve_API_reference</a> has may examples, after this, you should look those examples to further familiar with lp_solve.</strong>  The code of this turtorial can be found <strong><a href="https://github.com/lirui-shanghaitech/llvm_notes/tree/main/TUR_APP/lpsolve_tur">here</a></strong>.</p>
]]></content>
      <categories>
        <category>HLS</category>
      </categories>
      <tags>
        <tag>ILP</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM IR Tutorial</title>
    <url>/2021/03/24/llvm-ir/</url>
    <content><![CDATA[<h3 id="LLVM-IR-notes"><a href="#LLVM-IR-notes" class="headerlink" title="LLVM IR notes"></a>LLVM IR notes</h3><h4 id="Basic-constructs"><a href="#Basic-constructs" class="headerlink" title="Basic constructs"></a>Basic constructs</h4><h5 id="Global-variable"><a href="#Global-variable" class="headerlink" title="Global variable"></a>Global variable</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int variable &#x3D; 21;
@variable &#x3D; global i32 21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Globals are prefixed with the <code>@</code> character. You can see that also functions, such as <code>main</code>, are also global variables in LLVM. <strong>LLVM views global variables as pointers;</strong>  so you must explicitly dereference the global variable using the <code>load</code> instruction when accessing its value, likewise you must explicitly store the value of a global variable using the <code>store</code> instruction.</p>
<span id="more"></span>

<h5 id="Local-variables"><a href="#Local-variables" class="headerlink" title="Local variables"></a>Local variables</h5><ul>
<li>Temporary variables/Registers: created by introducing a new symbol for the variable</li>
<li>Stack-allocated local variables: created by allocating the variable on the stack</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">%reg &#x3D; add i32 4, 2
%stack &#x3D; alloca i32<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>Notice that <code>alloca</code> yields a pointer to the allocated type. As is generally the case in LLVM, you must explicitly use a <code>load</code> or <code>store</code> instruction to read or write the value respectively.</p>
<h5 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h5><ul>
<li>Constants that do <em>not</em> occupy allocated memory.</li>
<li>Constants that <em>do</em> occupy allocated memory.</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">%1 &#x3D; add i32 %0, 17     ; 17 is an inlined constant

@hello &#x3D; internal constant [6 x i8] c&quot;hello\00&quot;
%struct &#x3D; type &#123; i32, i8 &#125;
@struct_constant &#x3D; internal constant %struct &#123; i32 16, i8 4 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Such a constant is really a global variable whose visibility can be limited with <code>private</code> or <code>internal</code> so that it is invisible outside the current module.</p>
<h5 id="Structures"><a href="#Structures" class="headerlink" title="Structures"></a>Structures</h5><pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">struct Foo &#123; int a; char *b; double c; &#125;;
%Foo &#x3D; type &#123;
    i32,        ; 0: a
    i8*,        ; 1: b
    double      ; 2: c
&#125;
&#x2F;&#x2F;---------------------------------------------------------------------------------------
Foo foo;
char **bptr &#x3D; &amp;foo.b;

%foo &#x3D; alloca %Foo
&#x2F;&#x2F; char **bptr &#x3D; &amp;foo.b GetElementPointer GEP instruction
%1 &#x3D; getelementptr %Foo, %Foo* %foo, i32 0, i32 1
&#x2F;&#x2F;---------------------------------------------------------------------------------------
Foo bar[100];
bar[17].c &#x3D; 0.0;

; Foo bar[100]
%bar &#x3D; alloca %Foo, i32 100
; bar[17].c &#x3D; 0.0
%2 &#x3D; getelementptr %Foo, %Foo* %bar, i32 17, i32 2
store double 0.0, double* %2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="Casts"><a href="#Casts" class="headerlink" title="Casts"></a>Casts</h5><ul>
<li><strong>Bitwise casts (type casts)</strong>: A bitwise cast (<code>bitcast</code>) reinterprets a given bit pattern without changing any bits in the operand. </li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">Foo *foo &#x3D; (Foo *) malloc(sizeof(Foo));

%1 &#x3D; call i8* @malloc(i32 4)
%foo &#x3D; bitcast i8* %1 to %Foo*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Zero-extending casts (unsigned upcasts)</strong>: To upcast an unsigned value like in the example below using <code>zext</code></li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">uint8 byte &#x3D; 117;
uint32 word;
word &#x3D; byte;

@byte &#x3D; global i8 117
@word &#x3D; global i32 0
%1 &#x3D; load i8, i8* @byte
%2 &#x3D; zext i8 %1 to i32
store i32 %2, i32* @word<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Sign-extending casts (signed upcasts)</strong>: To upcast a signed value, you replace the <code>zext</code> instruction with the <code>sext</code> instruction </li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">@char &#x3D; global i8 -17
@int  &#x3D; global i32 0
%1 &#x3D; load i8, i8* @char
%2 &#x3D; sext i8 %1 to i32
store i32 %2, i32* @int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Truncating casts (signed and unsigned downcasts)</strong>: Both signed and unsigned integers use the same instruction, <code>trunc</code>, to reduce the size of the number in question. </li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">@int &#x3D; global i32 -1
@char &#x3D; global i8 0
%1 &#x3D; load i32, i32* @int
%2 &#x3D; trunc i32 %1 to i8
store i8 %2, i8* @char<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Floating-point extending casts (float upcasts)</strong>: Floating points numbers can be extended using the <code>fpext</code> instruction</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">@small &#x3D; global float 1.25
@large &#x3D; global double 0.0
%1 &#x3D; load float, float* @small
%2 &#x3D; fpext float %1 to double
store double %2, double* @large<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Floating-point truncating casts (float downcasts)</strong>: Likewise, a floating point number can be truncated to a smaller size using <code>fptrunc</code></li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">@large &#x3D; global double 1.25
@small &#x3D; global float 0.0
%1 &#x3D; load double, double* @large
%2 &#x3D; fptrunc double %1 to float
store float %2, float* @small<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>Pointer-to-integer casts</strong>: Pointers do not support arithmetic, which is sometimes needed when doing systems programming. LLVM has support for casting pointer types to integer types using the <code>ptrtoint</code> instruction.</li>
<li><strong>Integer-to-pointer casts</strong>: The <code>inttoptr</code> instruction is used to cast an integer back to a pointer</li>
<li><strong>Address-space casts (pointer casts)</strong>.</li>
</ul>
<h5 id="Function-Definitions-and-Declarations"><a href="#Function-Definitions-and-Declarations" class="headerlink" title="Function Definitions and Declarations"></a>Function Definitions and Declarations</h5><ul>
<li>Simple definition and Declaration</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">define  i32 @Bar() nounwind &#123; ret i32 17 &#125;
declare i32 @Bar(i32 %value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>With variable number of parameters</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">declare i32 @printf(i8*, ...) nounwind

@.textstr &#x3D; internal constant [20 x i8] c&quot;Argument count: %d\0A\00&quot;

define i32 @main(i32 %argc, i8** %argv) nounwind &#123;
    ; printf(&quot;Argument count: %d\n&quot;, argc)
    %1 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr([20 x i8], [20 x i8]* @.textstr, i32 0, i32 0), i32 %argc)
    ret i32 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Overloading: function names are mangled in the LLVM IR level</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">define i32 @_Z8functionii(i32 %a, i32 %b) #0 &#123;
; [...]
  ret i32 %5
&#125;

define double @_Z8functionddd(double %a, double %b, double %x) #0 &#123;
; [...]
  ret double %8
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>For the detailed description of <code>struct</code> arguments in the function please refer to this <a href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/basic-constructs/functions.html#struct-by-value-as-parameter-or-return-value">link</a></p>
</li>
<li><p>Function Points</p>
</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">int (*Function)(char *buffer);
@Function &#x3D; global i32(i8*)* null<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h5><p>TODO: since it is not commonly used today</p>
<h4 id="Control-Flow-Constructs"><a href="#Control-Flow-Constructs" class="headerlink" title="Control-Flow Constructs"></a>Control-Flow Constructs</h4><h5 id="if-then-else-conversion"><a href="#if-then-else-conversion" class="headerlink" title="if-then-else conversion"></a><code>if-then-else</code> conversion</h5><p>In LLVM IR control-flow is implemented by jumping between <em>basic blocks</em>, which contain instruction sequences that do not change control flow. Each basic block ends with an instruction that changes the control flow. The most common branching instruction is<a href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/control-structures/if-then-else.html#brlink"> <code>br</code> </a></p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&#x2F;&#x2F; Usage of br instruction
br i1 %cond, label %iftrue, label %iffalse
br label %dest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Max function example</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int max(int a, int b) &#123;
  if (a &gt; b) &#123;
    return a;
  &#125; else &#123;
    return b;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Translate into LLVM IR: there are four basic blocks</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">define i32 @max(i32 %a, i32 %b) &#123;
entry:
  %retval &#x3D; alloca i32, align 4
  %0 &#x3D; icmp sgt i32 %a, %b
  br i1 %0, label %btrue, label %bfalse

btrue:                                      ; preds &#x3D; %2
  store i32 %a, i32* %retval, align 4
  br label %end

bfalse:                                     ; preds &#x3D; %2
  store i32 %b, i32* %retval, align 4
  br label %end

end:                                     ; preds &#x3D; %btrue, %bfalse
  %1 &#x3D; load i32, i32* %retval, align 4
  ret i32 %1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="PHI"><a href="#PHI" class="headerlink" title="PHI"></a><code>PHI</code></h5><p>The <code>phi</code> instruction is named after the φ function used in the theory of SSA. This functions magically chooses the right value, depending on the control flow. In LLVM you have to manually specify the name of the value and the previous basic block.</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">%retval &#x3D; phi i32 [%a, %btrue], [%b, %bfalse]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>After using the <code>PHI</code> function the above max function can be transform to</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">define i32 @max(i32 %a, i32 %b) &#123;
entry:
  %0 &#x3D; icmp sgt i32 %a, %b
  br i1 %0, label %btrue, label %bfalse

btrue:                                      ; preds &#x3D; %2
  br label %end

bfalse:                                     ; preds &#x3D; %2
  br label %end

end:                                     ; preds &#x3D; %btrue, %bfalse
  %retval &#x3D; phi i32 [%a, %btrue], [%b, %bfalse]
  ret i32 %retval
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Usually the compiler back end will use the stack for implementing the <code>phi</code> instruction. However, if we use a little more optimization in the back end (i.e., <code>llc -O1</code>), we can get a more optimized version.</p>
<h4 id="Object-Oriented-Constructs"><a href="#Object-Oriented-Constructs" class="headerlink" title="Object Oriented Constructs"></a>Object Oriented Constructs</h4><h5 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h5><p>A class is nothing more than a structure with an associated set of functions that take an implicit first parameter, namely a pointer to the structure. Therefore, is is very trivial to map a class to LLVM IR</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stddef.h&gt;
class Foo
&#123;
public:
    Foo() &#123; _length &#x3D; 0; &#125;

    void SetLength(size_t value) &#123; _length &#x3D; value; &#125;
private:
    size_t _length;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>first transform this code into two separate pieces:</p>
<ul>
<li>The structure definition.</li>
<li>The list of methods, including the constructor.</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">; The structure definition for class Foo.
%Foo &#x3D; type &#123; i32 &#125;

; The default constructor for class Foo.
define void @Foo_Create_Default(%Foo* %this) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 0
    store i32 0, i32* %1
    ret void
&#125;

; The Foo::SetLength() method.
define void @Foo_SetLength(%Foo* %this, i32 %value) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 0
    store i32 %value, i32* %1
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Then we make sure that the constructor (<code>Foo_Create_Default</code>) is invoked whenever an instance of the structure is created.</p>
<h5 id="Virtual-Methods"><a href="#Virtual-Methods" class="headerlink" title="Virtual Methods"></a>Virtual Methods</h5><p>A virtual method is no more than a compiler-controlled function pointer. Each virtual method is recorded in the <code>vtable</code>, which is a structure of all the function pointers needed by a given class. Please refer this <a href="https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/object-oriented-constructs/index.html">link</a> to learn more about Objected-Oriented Constructs.</p>
<h4 id="Some-important-Instructions"><a href="#Some-important-Instructions" class="headerlink" title="Some important Instructions"></a>Some important Instructions</h4><h5 id="getelementptr-Ins-also-other-fantastic-notes-from-official-website"><a href="#getelementptr-Ins-also-other-fantastic-notes-from-official-website" class="headerlink" title="getelementptr Ins, also other fantastic notes from official website"></a><a href="https://llvm.org/docs/LangRef.html#id1743"><code>getelementptr</code> Ins</a>, also other fantastic notes from official <a href="https://llvm.org/docs/GetElementPtr.html">website</a></h5><p>Syntax</p>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">&lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*
&lt;result&gt; &#x3D; getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*
&lt;result&gt; &#x3D; getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>HLS</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Datapath synthesize in Verilog</title>
    <url>/2021/02/21/verilog-datapath-md/</url>
    <content><![CDATA[<h6 id="锁存器的综合："><a href="#锁存器的综合：" class="headerlink" title="锁存器的综合："></a>锁存器的综合：</h6><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> latch <span class="token punctuation">(</span>
    <span class="token keyword">output</span> q_out<span class="token punctuation">,</span>
    <span class="token keyword">input</span> data_in<span class="token punctuation">,</span> enable<span class="token punctuation">,</span> rst_b
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> q_out <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>rst_b <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span><span class="token punctuation">:</span>enable <span class="token operator">?</span> data_in<span class="token punctuation">:</span>q_out<span class="token punctuation">;</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>

<ul>
<li>当一条带条件操作符的连续赋值语句出现反馈时，综合工具将判断出它具有一个锁存器的功能，并给出它的硬件实现。</li>
<li>在赋值表达式的右逻辑发生变化的所有情况下，必须给行为中包含的所有变量赋值，否则会产生不想要的锁存器。因此所有用以实现组合逻辑的电平敏感行为电路的输入信号都必须包含于事件控制表达式中</li>
<li>电平敏感周期型行为中，赋值语句的右表达式中任意信号都不再出现于其左表达式中 （如果想要生成组合逻辑电路）</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//有意综合锁存器，注意非阻塞赋值&lt;= 的运用</span>

<span class="token comment">// 综合成带反馈的多路复用器结构</span>
<span class="token keyword">module</span> latch_if1 <span class="token punctuation">(</span>
    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span> <span class="token keyword">input</span> latch_enable
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>latch_enable<span class="token punctuation">)</span> data_out <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span> 
        <span class="token keyword">else</span> data_out <span class="token operator">&lt;=</span> data_out<span class="token punctuation">;</span> 
<span class="token keyword">endmodule</span>

<span class="token comment">// 综合成硬件锁存器</span>
<span class="token keyword">module</span> latch_if2 <span class="token punctuation">(</span>
    <span class="token keyword">output</span> <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> data_out<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span> <span class="token keyword">input</span> latch_enable
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>latch_enable<span class="token punctuation">)</span> data_out <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>In a level-sensitive cyclic behavior. If a case statement has a default assignment with feedback (i.e., the variable is explicitly assigned to itself), the synthesis tool will form a mux structure with feedback. </li>
<li>Likewise, if an if statement in a level-sensitive behavior assigns a variable to itself, the result will be a mux structure with feedback.</li>
<li>If the conditional operator is used in a continuous assignment, the result will be a mux with feedback. If it is used in a level-sensitive cyclic behavior, the result will be a hardware latch. </li>
<li>If the conditional operator is used in an edge-sensitive cyclic behavior, the result will be a register with a gated data path in a feedback configuration with the output of the register.</li>
</ul>
<h6 id="触发器的综合："><a href="#触发器的综合：" class="headerlink" title="触发器的综合："></a>触发器的综合：</h6><p>A register variable in an edge-sensitive behavior will be synthesized as a flip-flop</p>
<p>(1) A variable that is referenced within an edge-sensitive behavior before it is assigned value in the behavior will be synthesized as the output of a flip-flop.</p>
<p>(2) if it is referenced within the behavior before it is assigned value.</p>
<p>(3) if it is assigned value in only some of the branches of the activity within the behavior.</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 异步复位D触发器</span>
<span class="token keyword">module</span> asynch_df_behav <span class="token punctuation">(</span>
	<span class="token keyword">input</span> data<span class="token punctuation">,</span> set_b<span class="token punctuation">,</span> rst_b<span class="token punctuation">,</span> clk<span class="token punctuation">,</span>
	<span class="token keyword">output</span> <span class="token keyword">reg</span> q<span class="token punctuation">,</span> outputq_bar
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token important">always @</span><span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">,</span> <span class="token keyword">negedge</span> set_b<span class="token punctuation">,</span> <span class="token keyword">negedge</span> rst_b<span class="token punctuation">)</span> <span class="token keyword">begin</span>
        <span class="token function">if</span><span class="token punctuation">(</span>rst_b <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>q <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">if</span><span class="token punctuation">(</span>set_b <span class="token operator">==</span> <span class="token number">1'b0</span><span class="token punctuation">)</span>q <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    	<span class="token keyword">else</span> q <span class="token operator">&lt;=</span> data<span class="token punctuation">;</span> <span class="token comment">// synchronized activity </span>
    <span class="token keyword">end</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>综合工具只支持全部为边缘敏感或全部为电平敏感的事件控制表达式</li>
<li>always中的语句块为顺序执行，并且反复无限的执行</li>
<li>Recall that an incomplete conditional statement (i.e., an if … else statement or a case statement) in a level-sensitive cyclic behavior will synthesize to a latch. However, if the behavior is edge-sensitive, these types of statements will not create latches, but they will synthesize logic that implements a “clock enable,” because the incompletestatements imply that the affected variables should not change under the conditions implied by the logic, even though the clock makes a transition.</li>
</ul>
<h6 id="比较器的综合-连续赋值与寄存器传输模型的比较-："><a href="#比较器的综合-连续赋值与寄存器传输模型的比较-：" class="headerlink" title="比较器的综合 (连续赋值与寄存器传输模型的比较)："></a>比较器的综合 (连续赋值与寄存器传输模型的比较)：</h6><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> compare_32_CA #<span class="token punctuation">(</span><span class="token keyword">parameter</span> word__size <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
    <span class="token keyword">output</span> A_gt_B<span class="token punctuation">,</span>A_lt_B<span class="token punctuation">,</span>A_eq_B<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> <span class="token punctuation">[</span>word__size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>O<span class="token punctuation">]</span> A<span class="token punctuation">,</span> B
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">assign</span> A_gt_B <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">></span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">assign</span> A_lt_B <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">&lt;</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">assign</span> A_eq_B <span class="token operator">=</span> <span class="token punctuation">(</span>A<span class="token operator">==</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>关键词<code>assign</code> 定义了连续赋值，将右边等式的布尔表达式与左边的变量联系起来</li>
<li>基于连续赋值的建模方式用于描述电平敏感的行为，连续赋值语句之间，基本门之间以及描述中的所有行为模块之间都是并行执行的</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Comp_2_RTL <span class="token punctuation">(</span>
    <span class="token keyword">output</span> <span class="token keyword">reg</span> A_lt_B<span class="token punctuation">,</span>A_gt_B<span class="token punctuation">,</span>A_eq_B<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> A1<span class="token punctuation">,</span> A0<span class="token punctuation">,</span> B1<span class="token punctuation">,</span> B0
<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token important">always @</span> <span class="token punctuation">(</span>A0<span class="token punctuation">,</span> A1<span class="token punctuation">,</span> B0<span class="token punctuation">,</span> B1<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
        A_lt_B <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&#123;</span>A1<span class="token punctuation">,</span> A0<span class="token operator">&#125;</span> <span class="token operator">&lt;</span> <span class="token operator">&#123;</span>B1<span class="token punctuation">,</span> B0<span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        A_gt_B <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&#123;</span>A1<span class="token punctuation">,</span> A0<span class="token operator">&#125;</span> <span class="token operator">></span> <span class="token operator">&#123;</span>B1<span class="token punctuation">,</span> B0<span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
        A_eq_B <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">&#123;</span>A1<span class="token punctuation">,</span> A0<span class="token operator">&#125;</span> <span class="token operator">==</span> <span class="token operator">&#123;</span>B1<span class="token punctuation">,</span> B0<span class="token operator">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">end</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>无论数据通道的哪一位在任何时间发生变化，电平敏感的周期性行为都将不断的进行，不断更新它的输出</li>
<li>周期性行为的语句<code>顺序执行</code>，无限循环</li>
</ul>
<h6 id="移位寄存器的综合-阻塞与非阻塞赋值的区别-："><a href="#移位寄存器的综合-阻塞与非阻塞赋值的区别-：" class="headerlink" title="移位寄存器的综合 (阻塞与非阻塞赋值的区别)："></a>移位寄存器的综合 (阻塞与非阻塞赋值的区别)：</h6><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> shiftreg_PA <span class="token punctuation">(</span>
    <span class="token keyword">output</span> <span class="token keyword">reg</span> A<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> E<span class="token punctuation">,</span> clk<span class="token punctuation">,</span> rst
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">reg</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">;</span> 
    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">,</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rst <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span> 
            A<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> B<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> C<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> D<span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
        <span class="token keyword">end</span> <span class="token keyword">else</span> <span class="token keyword">begin</span> 
            A<span class="token operator">=</span>B<span class="token punctuation">;</span> B<span class="token operator">=</span> C<span class="token punctuation">;</span> C<span class="token operator">=</span> D<span class="token punctuation">;</span> D<span class="token operator">=</span> E<span class="token punctuation">;</span> 
        <span class="token keyword">end</span>
    <span class="token keyword">end</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>阻塞赋值<code>=</code> ，进行过程赋值的语句必须在行为中的下一条语句执行之前完成执行过程（把结果写入寄存器中）。紧随其后的过程赋值语句被阻塞执行，直到正在执行的过程赋值语句完成执行任务时为止</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> shiftreg_nb_V05 <span class="token punctuation">(</span>
	<span class="token keyword">output</span> <span class="token keyword">reg</span> A<span class="token punctuation">,</span>
    <span class="token keyword">input</span> E<span class="token punctuation">,</span> clk<span class="token punctuation">,</span> rst
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">reg</span> B<span class="token punctuation">,</span>C<span class="token punctuation">,</span> D<span class="token punctuation">;</span> 
    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">,</span> <span class="token keyword">posedge</span> rst<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
        <span class="token function">if</span><span class="token punctuation">(</span>rst<span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span> <span class="token keyword">begin</span> A<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span> B<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span>C<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span> D<span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">end</span> 
    	<span class="token keyword">else</span> <span class="token keyword">begin</span> 
            A <span class="token operator">&lt;=</span> B<span class="token punctuation">;</span> <span class="token comment">// D &lt;= E; </span>
            B <span class="token operator">&lt;=</span> C<span class="token punctuation">;</span> <span class="token comment">// C &lt;= D; </span>
            C <span class="token operator">&lt;=</span> D<span class="token punctuation">;</span> <span class="token comment">// B &lt;= C; </span>
            D <span class="token operator">&lt;=</span> E<span class="token punctuation">;</span> <span class="token comment">// A &lt;= B; </span>
        <span class="token keyword">end</span>
    <span class="token keyword">end</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>非阻塞赋值<code>&lt;=</code> , 非阻塞赋值语句可以并发的执行，语句在列表中的排列顺序对最终的结果没有影响，一般仿真器在给左边目标赋值之前要计算每一个右表达式的值</li>
<li>非阻塞赋值表达式的左变量必须为<code>reg</code>类型</li>
<li>边沿敏感（同步）操作尽量用非阻塞赋值来完成，组合逻辑尽量用阻塞赋值来描述</li>
</ul>
<h6 id="计数器的综合："><a href="#计数器的综合：" class="headerlink" title="计数器的综合："></a>计数器的综合：</h6><h6 id="移位寄存器的综合："><a href="#移位寄存器的综合：" class="headerlink" title="移位寄存器的综合："></a>移位寄存器的综合：</h6><h6 id="寄存器的综合："><a href="#寄存器的综合：" class="headerlink" title="寄存器的综合："></a>寄存器的综合：</h6><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Register_File #<span class="token punctuation">(</span><span class="token keyword">parameter</span> word_size <span class="token operator">=</span> <span class="token number">32</span><span class="token punctuation">,</span> addr_size <span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
    <span class="token keyword">output</span> <span class="token punctuation">[</span>word_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> Data_Out_1<span class="token punctuation">,</span> Data_Out_2<span class="token punctuation">,</span> 
	<span class="token keyword">input</span> <span class="token punctuation">[</span>word_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Data_in<span class="token punctuation">,</span> 
	<span class="token keyword">input</span> <span class="token punctuation">[</span>addr_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Read_Addr_1<span class="token punctuation">,</span> Read_Addr_2<span class="token punctuation">,</span> Write_Addr<span class="token punctuation">,</span> 
	<span class="token keyword">input</span> Write_Enable<span class="token punctuation">,</span> Clock
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">reg</span> <span class="token punctuation">[</span>word_size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Reg_File <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 32bit x32 word memory declaration </span>
	<span class="token keyword">assign</span> Data_Out_1 <span class="token operator">=</span> Reg_File<span class="token punctuation">[</span>Read_Addr_1<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">assign</span> Data_Out_2 <span class="token operator">=</span> Reg_File<span class="token punctuation">[</span>Read_Addr_2<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> Clock<span class="token punctuation">)</span> <span class="token keyword">begin</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Write_Enable <span class="token operator">==</span> <span class="token number">1'b1</span><span class="token punctuation">)</span> Reg_File<span class="token punctuation">[</span>Write_Addr<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> Data_in<span class="token punctuation">;</span> 
    <span class="token keyword">end</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="组合逻辑的综合："><a href="#组合逻辑的综合：" class="headerlink" title="组合逻辑的综合："></a>组合逻辑的综合：</h6><ul>
<li>结构化的原语网表</li>
<li>一系列连续赋值语句</li>
<li>电平敏感的周期性行为 （内部无反馈并且没有锁存器）</li>
</ul>
<h6 id="for的综合："><a href="#for的综合：" class="headerlink" title="for的综合："></a><code>for</code>的综合：</h6><ul>
<li>Provide a shorter way to express a series of statements</li>
<li>Loop index variables must be integer type</li>
<li>Step, start &amp; end value must be constant</li>
<li>In synthesis, for loops loops are “unrolled” , and then synthesized</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always@</span><span class="token punctuation">(</span> a <span class="token keyword">or</span> b <span class="token punctuation">)</span>
	<span class="token keyword">begin</span>
		<span class="token function">for</span><span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">)</span>
			c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Unrolled版本</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always@</span><span class="token punctuation">(</span> a <span class="token keyword">or</span> b <span class="token punctuation">)</span>
    <span class="token keyword">begin</span>
        c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        c<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        c<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h6 id="Case和if的综合："><a href="#Case和if的综合：" class="headerlink" title="Case和if的综合："></a><code>Case</code>和<code>if</code>的综合：</h6><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">// 优先级选择器</span>
<span class="token keyword">module</span> mux_4pri <span class="token punctuation">(</span>
    <span class="token keyword">output</span> <span class="token keyword">reg</span> y<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> sel_a<span class="token punctuation">,</span> sel_b<span class="token punctuation">,</span> sel_c
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token important">always @</span> <span class="token punctuation">(</span>sel_a<span class="token punctuation">,</span> sel_b<span class="token punctuation">,</span> sel_c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span>
<span class="token comment">//  always @ (") Optional wildcard token for complete sensitivity list </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sel_a<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> y <span class="token operator">=</span> a<span class="token punctuation">;</span> 
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sel_b<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> y <span class="token operator">=</span> b<span class="token punctuation">;</span> 
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sel_c <span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> y <span class="token operator">=</span> c<span class="token punctuation">;</span> 
                <span class="token keyword">else</span> y <span class="token operator">=</span> d<span class="token punctuation">;</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>case</code>和<code>if</code>语句一般被综合成组合电路</li>
<li><code>case</code>语句通常隐含的对首先解码的选项赋予较高优先权，而<code>if</code>语句则隐含指定第一个分支具有更高优先权。综合工具会先判断<code>case</code>中的分支选择是否互斥，如果互斥，综合工具认为它们具有相同的优先级，综合成为一个多路选择器，如何不互斥则综合为优先级结构</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> alu_with_z1 <span class="token punctuation">(</span>
    <span class="token keyword">output</span> alu_out<span class="token punctuation">,</span> 
    <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> data_a<span class="token punctuation">,</span> data_b<span class="token punctuation">,</span> <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> opcode<span class="token punctuation">,</span> <span class="token keyword">input</span> enable
<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> alu_reg<span class="token punctuation">;</span> 
    <span class="token keyword">assign</span> alu_out <span class="token operator">=</span> <span class="token punctuation">(</span>enable <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> alu_reg <span class="token punctuation">:</span> <span class="token number">4'bz</span><span class="token punctuation">;</span> 
    <span class="token important">always @</span> <span class="token punctuation">(</span>opcode<span class="token punctuation">,</span> data_a<span class="token punctuation">,</span> data_b<span class="token punctuation">)</span>
        <span class="token keyword">case</span> <span class="token punctuation">(</span>opcode<span class="token punctuation">)</span>
            <span class="token number">3'b001</span><span class="token punctuation">:</span> alu_reg <span class="token operator">=</span> data_a <span class="token operator">|</span>data_b<span class="token punctuation">;</span>
            <span class="token number">3'b010</span><span class="token punctuation">:</span> alu_reg <span class="token operator">=</span> data_a <span class="token operator">^</span> data_b<span class="token punctuation">;</span>
            <span class="token number">3'b110</span><span class="token punctuation">:</span> alu_reg <span class="token operator">=</span> <span class="token operator">~</span>data_b<span class="token punctuation">;</span> 
            <span class="token keyword">default</span><span class="token punctuation">:</span> alu_reg <span class="token operator">=</span> <span class="token number">4'b0</span><span class="token punctuation">;</span> <span class="token comment">// alu_with_z2 has default: alu_reg = 4'bx; </span>
        <span class="token keyword">endcase</span> 
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>缺少默认赋值语句会使<code>寄存器变量</code>输出锁存，综合工具会自动生成锁存器 （在条件未定义时保持输出原值）</li>
<li>当对默认赋值语句没有限制时（e.g., 4’bx）综合工具将视为无关紧要条件，减少电路所需逻辑</li>
<li>如果一个条件操作符将<code>z</code>值放在电平敏感行为中连续赋值的右表达式中，那么该语句将会综合成通过组合逻辑驱动的一个三态器件中</li>
</ul>
]]></content>
      <categories>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>Verilog in a NutShell</title>
    <url>/2021/04/05/verilog-netshell/</url>
    <content><![CDATA[<h1 id="Verilog-in-a-NutShell"><a href="#Verilog-in-a-NutShell" class="headerlink" title="Verilog in a NutShell"></a>Verilog in a NutShell</h1><p><strong>This is a detour to better understand the GenerateRTL phase of LegUp HLS</strong></p>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="电路结构的三种描述方法"><a href="#电路结构的三种描述方法" class="headerlink" title="电路结构的三种描述方法"></a>电路结构的三种描述方法</h3><ul>
<li>数据流描述: 采用assign 语句，该语句被称为连续赋值语句。</li>
<li>行为描述:使用always 或initial 语句块，其中出现的语句被称为过程赋值语句。</li>
<li>结构化描述:实例化已有的功能模块。</li>
</ul>
<span id="more"></span>

<h3 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h3><h4 id="模块与端口"><a href="#模块与端口" class="headerlink" title="模块与端口"></a>模块与端口</h4><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps
<span class="token keyword">module</span> <span class="token function">SIMDadd</span><span class="token punctuation">(</span>
        <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span>
        <span class="token keyword">input</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> B<span class="token punctuation">,</span>
        <span class="token keyword">input</span> H<span class="token punctuation">,</span>
        <span class="token keyword">input</span> O<span class="token punctuation">,</span>
        <span class="token keyword">input</span> Q<span class="token punctuation">,</span>
        <span class="token keyword">input</span> sub<span class="token punctuation">,</span>
        <span class="token keyword">output</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> Cout
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//声明语句</span>
    <span class="token comment">/* reg,wire, parameter,
	input,output,inout,
	function, task ... */</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> B_real <span class="token operator">=</span> sub<span class="token operator">?</span><span class="token punctuation">(</span><span class="token operator">~</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>B<span class="token punctuation">;</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C0 <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>   <span class="token operator">+</span>  B_real<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token operator">+</span> sub<span class="token punctuation">;</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C1 <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>   <span class="token operator">+</span>  B_real<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>    <span class="token operator">+</span> <span class="token punctuation">(</span>C0<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>O<span class="token operator">|</span>H<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Q<span class="token operator">&amp;</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C2 <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>  <span class="token operator">+</span>  B_real<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>   <span class="token operator">+</span> <span class="token punctuation">(</span>C1<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&amp;</span>H<span class="token punctuation">)</span>     <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Q<span class="token operator">|</span>O<span class="token punctuation">)</span><span class="token operator">&amp;</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> C3 <span class="token operator">=</span> A<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">+</span>  B_real<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">:</span><span class="token number">12</span><span class="token punctuation">]</span>  <span class="token operator">+</span> <span class="token punctuation">(</span>C2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>O<span class="token operator">|</span>H<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Q<span class="token operator">&amp;</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">//语句</span>
    <span class="token keyword">assign</span> Cout <span class="token operator">=</span> <span class="token operator">&#123;</span>C3<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>C2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>C1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>C0<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&#125;</span><span class="token punctuation">;</span>
    <span class="token comment">/* initial 语句
    always 语句
    module 实例化
    assign 连续赋值 */</span>
    
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h4><p>Verilog使用`来表示编译指令编译器一旦遇到某个编译指令，则该指令将在整个编译过程中有效，直到编译器遇到另一个相同的编译指令为止。</p>
<ul>
<li>`timescale 1ns/100ps 其中1ns 表 示延时单位. 100ps 表示时间精度，也就是编译器所能接收的最小仿真时间粒度。</li>
<li>`define用于定义宏例如可以首先定义一个总线宽度的宏为16 ，然后利用这个宏定义 一个宽度为16 的reg 类型数据Data。在一个文件中出现的、define 可以被多个文件使用，也就是说 define 是一种全局性定<br>义，这是define 与parameter 定义的最大区别。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`define</span> BUS_WIDTH <span class="token number">16</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token constant">`BUS_WIDTH</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> Data<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>`ifdef用于条件编译，如下所示，如果先前已经定义了NARROW宏，则参数为16，否则为32</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token constant">`ifdef</span> NARROW
	<span class="token keyword">parameter</span> BUS WIDTH <span class="token number">16</span><span class="token punctuation">;</span>
<span class="token constant">`else</span>
	<span class="token keyword">parameter</span> BUS W 工DTH <span class="token number">32</span><span class="token punctuation">;</span>
<span class="token constant">`endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>`include 用于嵌入某个文件的内容</li>
</ul>
<h3 id="驱动与赋值"><a href="#驱动与赋值" class="headerlink" title="驱动与赋值"></a>驱动与赋值</h3><ul>
<li>线网是被驱动的，该值不被存储，在任意一个仿真步进上都需要重新计算。</li>
<li>寄存器是被赋值的，且该值将在仿真过程中被保存，直到再次对该变量进行赋值。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> A_xor_wire<span class="token punctuation">;</span>
<span class="token keyword">assign</span> <span class="token number">#1</span> A <span class="token keyword">xor</span> <span class="token keyword">wire</span> eqO<span class="token operator">^</span>eq1<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span>eqO <span class="token keyword">or</span> eq1<span class="token punctuation">)</span>
	A_xor_wire <span class="token operator">=</span> <span class="token number">#1</span> eqO<span class="token operator">^</span>eq1<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>第一种描述方式使用<code>assign</code>语句， Verilog 中将其称为连续赋值语句( Continously Assignment) ，实际就是连续驱动的过程，也就是说在任意一个仿真时刻，当前时刻eq0 和eq1相异或的结果决定了1ns 以后(语句#1 的延时控制)线网变量A_xor_wire 的值，不 管eq0 和eq1 变化与否，这个驱动过程一直在在，因此称为连续驱动。要知道，在仿真器中，线网变量是不占用仿真内存空间的。</p>
<p>第二种描述方式使用了”always” 语句，后面紧跟一个敏感列表@ (eq0 or eq1) ，该语句 只有在eq0 或eq1 发生变化后才会执行,在eq0和eq1没有发生变化时，A_xor_wire需要保持原来的值不变。因此从仿真语义上讲，需要一个存储单元，也可以说是寄存器，来保存 A_xor_wire 变量的中间值，这就是Verilog 语言中寄存器类型变量的来历，而这个 A_xor_wire 变量需要被定义为reg 类型。注意这里A_xor_wire虽然并定义成了reg类型，但是在综合后该描述被综合成了纯组合电路。</p>
<h3 id="并发与顺序"><a href="#并发与顺序" class="headerlink" title="并发与顺序"></a>并发与顺序</h3><p>在Verilog 语言的module 中，所有描述语句(包括连续赋值语句、行为语句块always 和initial 以及模块实例化等)都是并行发生的。 在语句块always 和initial 语句块内部可以存在两种语句组。</p>
<ul>
<li><code>begin ... end;</code>: 顺序语句组</li>
<li><code>fork ... join;</code>: 并行语句组</li>
</ul>
<h2 id="描述方式与设计层次"><a href="#描述方式与设计层次" class="headerlink" title="描述方式与设计层次"></a>描述方式与设计层次</h2><h3 id="数据流描述"><a href="#数据流描述" class="headerlink" title="数据流描述"></a>数据流描述</h3><p>在数字电路中，信号经过组合逻辑时会类似于数据流动，即信号从输入流向输出，并不 会在其中存储。当输入发生变化时，总会在一定时间以后体现在输出端。同样，我们可以模 拟数字电路的这二特性，对其进行建模，这种建模方式通常被称为数据流建模。数据流描述 中最基本的语句是<code>assign</code> 连续赋值语句。多用来对组合电路进行建模。</p>
<ul>
<li><p><strong>连续驱动</strong>： 只要输入变化，就会导致该语句的重新计算</p>
</li>
<li><p><strong>只有线网类型的变量才可在assign语句中被赋值</strong>：连续赋值语句中被赋值的变量在仿真器中不会存储其值，因此该变量是线网类型(Net) 的，而不是寄存器类塑的。 另外，线网类型的变量可以被多重驱动，也就是说可以在多个连续赋值语句中驱动同一个线网。</p>
</li>
<li><p><strong>并行性</strong>：多个assign语句之间时并行执行的</p>
</li>
</ul>
<h4 id="多驱动线网"><a href="#多驱动线网" class="headerlink" title="多驱动线网"></a>多驱动线网</h4><p>可以使用wor 线网类型将不同的输出”线或”在一起。同样，可以使用wand 线网类型将不同的输出”线与”在一起。如果要实现多个三态总线相连，可以采用tri型线网。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> <span class="token function">WO</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> WireOr， WireTri<span class="token punctuation">,</span> En1_n<span class="token punctuation">,</span> En2_n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">input</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">;</span>
    <span class="token keyword">output</span> WireOr<span class="token punctuation">;</span>
    <span class="token keyword">wor</span> WireOr<span class="token punctuation">;</span> <span class="token comment">//显式定义为wor 类型</span>
    <span class="token keyword">assign</span> WireOr <span class="token operator">=</span> A <span class="token operator">^</span> B<span class="token punctuation">;</span>
    <span class="token keyword">assign</span> WireOr <span class="token operator">=</span> C <span class="token operator">&amp;</span> D<span class="token punctuation">;</span>
    
    <span class="token keyword">output</span> WireTri<span class="token punctuation">;</span>
    <span class="token keyword">tri</span> WireTri<span class="token punctuation">;</span> <span class="token comment">//显式定义为tri 类型</span>
    <span class="token keyword">assign</span> WireTri <span class="token operator">=</span> <span class="token punctuation">(</span>En1_n<span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">1'bZ</span> <span class="token punctuation">(</span>A<span class="token operator">^</span>B<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">assign</span> WireTri <span class="token operator">=</span> <span class="token punctuation">(</span>En2_n<span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">1'bZ</span> <span class="token punctuation">(</span>C<span class="token operator">&amp;</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="行为描述"><a href="#行为描述" class="headerlink" title="行为描述"></a>行为描述</h3><p>在initial 和always 的后面-般要跟语句或语句组( statement group) 。 语句可以是非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编辑语句。initial 语句在0 仿真时间执行，丽且只执行一次always 语句同样在0仿真时间开始执行，但是它将一直循环执行。</p>
<h4 id="过程赋值语句"><a href="#过程赋值语句" class="headerlink" title="过程赋值语句"></a>过程赋值语句</h4><p>所谓过程赋值语句就是在initial 和always 语句块中的赋值语句。<strong>赋值对象只能是寄存器变量</strong>。右边的表达式可以是任意操作符的表达式。</p>
<h5 id="阻塞赋值"><a href="#阻塞赋值" class="headerlink" title="阻塞赋值"></a>阻塞赋值</h5><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">寄存器变量 <span class="token operator">=</span> 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>右边表达式的计算和对左边寄在器变量的赋值是一个统一的原子操作中的两个动作，这两个动作之间不能再插入其他任何动作。</li>
<li>如果有多个阻塞赋值语句顺序出现在begin…end 语句中，则前面的语句在执行时将完全阻塞后面的语句，直到前面语旬的赋值完成以后，才会执行下一句中右边表达式的 计算。</li>
</ul>
<h5 id="非阻塞赋值"><a href="#非阻塞赋值" class="headerlink" title="非阻塞赋值"></a>非阻塞赋值</h5><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog">寄存器变量 <span class="token operator">&lt;=</span> 表达式<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>在执行该语句时，首先计算右边的表达式，而且并不立刻为左边的变量赋值。如果有多个非阻塞赋值语句顺序出现在begín…end 语句中，那么前面语句的执行并不会阻塞后面语句的执行。</p>
<h5 id="语句组"><a href="#语句组" class="headerlink" title="语句组"></a>语句组</h5><p>主要了解以下<code>fork ... join</code>: 语句组中语句是并行执行的</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">initial</span>
    <span class="token keyword">fork</span>
        DataBin <span class="token number">0</span><span class="token punctuation">;</span>
        # <span class="token number">6</span> DataBin <span class="token number">0</span><span class="token punctuation">;</span>
        # <span class="token number">4</span> DataBin <span class="token number">1</span><span class="token punctuation">;</span>
        # <span class="token number">2</span> DataBin <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">join</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将产生如下的波形</p>
<img src="/images/image-20210403103930794.png" alt="image-20210403103930794" style="zoom:50%;" />

<h5 id="编程语句"><a href="#编程语句" class="headerlink" title="编程语句"></a>编程语句</h5><h6 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a><code>if-else</code> 语句</h6><p>if 语句后面跟语句或语句组(begin…end 或fork…join) ，常和else 搭配来实现不同条件下的各种情况。if 也可以单独使用。</p>
<ul>
<li>在if-else 语句中，条件是从上到下逐条检查的。因此当满足一个条件时，就会执行其后的语句，跳过else 后面的语句。当所有条件都不满足时，便执行最后-条else 后面的语句。可以说if-else 语句是有优先级顺序的。</li>
<li>在使用if…else 语句时，尤其是当该语句被用在组合逻辑中时，需要注意不要引入Latch 电路</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span><span class="token punctuation">(</span>sel <span class="token keyword">or</span> a <span class="token keyword">or</span> b <span class="token keyword">or</span> c<span class="token punctuation">)</span>
    <span class="token keyword">begin</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b00</span><span class="token punctuation">)</span>
    		q <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b01</span><span class="token punctuation">)</span>
    		q <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>sel <span class="token operator">==</span> <span class="token number">2'b10</span><span class="token punctuation">)</span>
    		q <span class="token operator">=</span> c<span class="token punctuation">;</span>
    <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后一个条件<code>sel==2&#39;b11</code>的语句没有被写出，言下之意是，当sel 为2’b11 时, q 值需要保持不变。这个代码在综合时会产生锁存器。</p>
<h6 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a><code>case</code>语句</h6><ul>
<li><p>与if-else 语句不同的是，在case 语句中，所有被判断的分支条件都具有一样的优先级。</p>
</li>
<li><p>与if-else 语句类似的是，case 语句同样需要考虑所有可能的情况，否则将会产生出不想要的锁存器。</p>
</li>
<li><p>case语句有两个派生语句<code>casez, casex</code> ,casez 语句将分支条件中所有的z 都看作”不关心”的值，而不看作任何逻辑值。条件中的z 可以改写为？，casex 语句将分支条件中所有的x 和z 都看作”不关心”的值，而不看作任何逻辑值。</p>
</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">casex</span> <span class="token punctuation">(</span>encoder<span class="token punctuation">)</span>
	<span class="token number">4'b1xxx</span> <span class="token punctuation">:</span> high_val <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
	<span class="token number">4'b01xx</span> <span class="token punctuation">:</span> high_val <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token number">4'b001x</span> <span class="token punctuation">:</span> high_val <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token number">4'b0001</span> <span class="token punctuation">:</span> high_val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">default</span> <span class="token punctuation">:</span> high_val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里通过casex语句生成了一个优先级译码器。</p>
<h6 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h6><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">forever</span> <span class="token number">#25</span> clk <span class="token operator">=</span> <span class="token operator">~</span>clk<span class="token punctuation">;</span>	  <span class="token comment">// 永远重复循环体	</span>
<span class="token keyword">repeat</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span>  <span class="token comment">// 重复循环体八次</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>条件<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="结构化描述"><a href="#结构化描述" class="headerlink" title="结构化描述"></a>结构化描述</h3><p>结构化描述就是说在设计中实例化己有的功能模块，这些功能模块包括门原语、用户自定义原语(UDP) 和其他模块(module)。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> Ha1fAdd <span class="token punctuation">(</span>X <span class="token punctuation">,</span> Y<span class="token punctuation">,</span> SUM<span class="token punctuation">,</span> C out<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//半加器模块</span>
HalfAdd <span class="token function">u_HalfAdd_B</span><span class="token punctuation">(</span> 				<span class="token comment">//半加器实例B</span>
    <span class="token punctuation">.</span>X <span class="token punctuation">(</span>C in<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>Y <span class="token punctuation">(</span>HalfAdd A SUM<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>SUM <span class="token punctuation">(</span>SUM<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>C_out <span class="token punctuation">(</span>HalfAdd_B_COUT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="/images/image-20210403114137701.png" alt="image-20210403114137701" style="zoom: 67%;" />

<h4 id="参数化模块"><a href="#参数化模块" class="headerlink" title="参数化模块"></a>参数化模块</h4><p>module 中的参数一般是用作定义其中常量的工具。在Verilog 语言中，当实例化模块时，用户可以修改模块中的参数，用来实现不同的特性。这个定制过程是通过”新参数直接代入”或”参数重定义”来完成的。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> mymodule <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">parameter</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">parameter</span> b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="参数定制方法"><a href="#参数定制方法" class="headerlink" title="参数定制方法"></a>参数定制方法</h5><ul>
<li>通过<code>defparam</code> 关键字重新定义模块中的参数, 使用<code>defparam</code> 的方法重新定义参数时，可以根据需要重新定义部分参数，而其他参数将保留缺省值。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> xxx <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	mymodule M1 <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//实例化mymodule</span>
	<span class="token keyword">defparam</span> 
		M1<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>		<span class="token comment">//重新定义M1中的参数a和b</span>
		M1<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
   	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>直接在实例化模块时带入参数，使用这种参数直接代入法时需要注意一点，即所有的参数都要按顺序列出来，不能遗漏，也不能颠倒顺序，否则就会对应不上。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> xxx <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	mymodule #<span class="token punctuation">(</span>
		<span class="token number">3</span><span class="token punctuation">,</span> 				<span class="token comment">// 重新定义M1中的参数a和b</span>
		<span class="token number">4</span><span class="token punctuation">)</span> M1 <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//实例化mymodule</span>
   	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="RTL级建模"><a href="#RTL级建模" class="headerlink" title="RTL级建模"></a>RTL级建模</h2><p>所谓寄存器传输级(RTL 级)就是在描述电路的时候，只需要关注寄存器本身，以及寄存器到寄存器之间的逻辑功能，而不用关心寄存器和组合逻辑的实现细节(具体用了多少逻辑门等)。典型的RTL设计分为三个部分：</p>
<ul>
<li><strong>时钟域描述</strong>: 描述设计中使用的所有时钟、时钟之间的主从与派生关系以及时钟域之间的转换。</li>
<li><strong>时序逻辑描述(寄存器描述)</strong>: 根据时钟沿的变换，描述寄存器之间的数据传输方式。</li>
<li><strong>组合逻辑描述</strong>: 描述电平敏感信号的逻辑组合方式和逻辑功能。</li>
</ul>
<h3 id="常用建模方式"><a href="#常用建模方式" class="headerlink" title="常用建模方式"></a>常用建模方式</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ul>
<li><p>对于时序逻辑，即always 模块的敏感表为边沿敏感信号(多为时钟或复位的正沿或负沿)，统一使用非阻塞赋值”&lt;=”。</p>
</li>
<li><p>对于always 模块的敏感表为电平敏感信号的组合逻辑，统一使用阻塞赋值”=”。</p>
</li>
<li><p>对于assign 关键宇描述的组合逻辑(通常称之为连续赋值语句) ，统一使用”=” 变量被定义为wire型信号。</p>
</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_out<span class="token punctuation">;</span>
a1ways@<span class="token punctuation">(</span><span class="token keyword">posedge</span> c1ock<span class="token punctuation">)</span>
	cnt_out <span class="token operator">&lt;=</span> cnt_out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
a1ways@<span class="token punctuation">(</span>cnt_out<span class="token punctuation">)</span>
	cnt_out_p1us <span class="token operator">=</span> cnt_out <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>	<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="寄存器电路的建模"><a href="#寄存器电路的建模" class="headerlink" title="寄存器电路的建模"></a>寄存器电路的建模</h4><ul>
<li><strong>寄存器信号声明</strong>: 寄存器被定义为reg 型，只有当信号被定义为reg 型，且处理该信号的always 敏感表为<code>posedge </code>或<code>negedge </code>沿敏感时，该信号才会被实现为寄存器。</li>
<li><strong>时钟输入</strong>: 在每个时钟的正沿或负沿对数据进行处理.时钟的正沿有效还是负沿有效，是由always 敏感表中的<code>posedge</code> 或<code>negedge</code> 决定的。</li>
<li><strong>异步复位/置位</strong>: 绝大多数目标器件的寄存器模型都包含异步复位/置位端.所谓异步复位/置位，是指无论时钟沿是否有效，当复位/置位信号的有效沿到达时，复位/置位会立即发挥功能.指定异步复位/置位时，只需在always 的敏感表中加入复位/置位信号的有效沿即可.下面描述的异步复位电路是最常用的寄存器复位形式之一。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_reg<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock <span class="token keyword">or</span> <span class="token keyword">negedge</span> reset <span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> reset <span class="token punctuation">)</span>
    	cnt <span class="token keyword">reg</span> <span class="token operator">&lt;=</span> <span class="token number">4</span>'bOOOO<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>同步复位/置位</strong>: 任何寄存器都可以实现同步复位/置位功能.指定同步复位/置位时always 的敏感表中仅有时钟沿信号，当同步复位/置位信号发生变化时，同步复位/置位并不立即发生，仅当时钟沿采到同步复位/置位的有效电平时，才会在时钟沿到达时刻进行复位/置位操作。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> cnt_reg<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clock<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> reset <span class="token punctuation">)</span>
    	cnt <span class="token keyword">reg</span> <span class="token operator">&lt;=</span> <span class="token number">4</span>'bOOOO<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>同时使用时钟上升沿和下降沿的问题</strong>: 有时因为数据采样或调整数据相位等需求，设计者会在一个always 的敏感表中同时使用时钟的posedge 和negedge ，或者在两个always 的敏感表中分别使用时钟的posedge 和negedge ，对某些寄存器电路进行操作(在这两种描述下，当时钟上升沿或时钟下降沿到达时，该寄存器电路都会做相应的操作. 这个双沿电路往往可以等同于使用了原时钟的倍频时钟的单沿操作电路).对于PLD 设计而言，不推荐同时使用时钟的上升沿、下降沿，因为PLD 内嵌的PLL/DLL 和一些时钟电路往往只能对时钟的一个沿保证非常好的指标，而另一个沿的抖动、偏斜、斜率等指标不见得非常优化，有时同时使用时钟的正、负沿会因时钟的抖动、偏斜、占空比、斜率等问题而造成一定的性能恶化。因此推荐的做法是，将原时钟通过PLL/DLL 倍频，然后使用倍频时钟的单沿(如上升沿)进行操作。</li>
</ul>
<h4 id="组合逻辑建模"><a href="#组合逻辑建模" class="headerlink" title="组合逻辑建模"></a>组合逻辑建模</h4><ul>
<li><p><strong>always 模块的敏感表为电平敏感信号的组合逻辑电路</strong>： 这种形式的组合逻辑电路应用非常广泛，如果不考虑代码的复杂性，几乎任何组合逻辑电路都可以用这种方式建模。always 模块的敏感表为所有判定条件和输入信号，请读者在使用这种结构描述组合逻辑时，一定要将敏感表写完整。在always模块中可以使用if.. .else… 、case 、for 循环等各种RTL 关键宇结构。在always 模块中推荐使用阻塞赋值”=”虽然信号被定义为reg 型，但是最终综合实现的结果并不是寄存器，而是组合逻辑，将信号定义为reg 型只是为了满足语法要求而已。</p>
</li>
<li><p><strong>assign 等语句描述的组合逻辑电路</strong>： 这种形式的组合逻辑电路适用于描述那些相对简单的组合逻辑，信号一般被定义为wire 型，常用的assign 结构除了直接赋值逻辑表达式外，还可以使用?语句。</p>
</li>
</ul>
<h4 id="双向端口与三态信号建模"><a href="#双向端口与三态信号建模" class="headerlink" title="双向端口与三态信号建模"></a>双向端口与三态信号建模</h4><ul>
<li>仅在顶层定义双向总线和实例化的三态信号，禁止在除顶层以外的其他层次赋值高阻态”z” ，在顶层将双向信号分为输入信号和输出信号两种类型，然后根据需要分别传递到不同的子模块中。这样做的另一个好处在于便于描述仿真激励。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">inout</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_bus<span class="token punctuation">;</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span> data_out<span class="token punctuation">;</span>
<span class="token keyword">assign</span> data_in  <span class="token operator">=</span> data_bus<span class="token punctuation">;</span>					<span class="token comment">//输入输出分离</span>
<span class="token keyword">assign</span> data_bus <span class="token operator">=</span> <span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token operator">?</span> data_out <span class="token punctuation">:</span> <span class="token number">8'bZ</span><span class="token punctuation">;</span>	<span class="token comment">//三态输出</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Mux建模"><a href="#Mux建模" class="headerlink" title="Mux建模"></a>Mux建模</h4><ul>
<li>简单的Mux 用?表达式建模，信号被定义为wire 型，使用?表达式的判断条件描述Mux 选择端的逻辑关系。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> mux_out<span class="token punctuation">;</span>
<span class="token keyword">assign</span> mux_out <span class="token operator">=</span> <span class="token punctuation">(</span>en<span class="token punctuation">)</span><span class="token operator">?</span> a<span class="token punctuation">:</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>复杂的Mux 用case 或嵌套的if.. .else 建模，信号被定义为reg 型， <code>case</code> 或<code>if.. .else</code> 的每个条件分支均分别对应Mux 的某路选择输出。</li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> mux_out<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span>en <span class="token keyword">or</span> a <span class="token keyword">or</span> b <span class="token keyword">or</span> C <span class="token keyword">or</span> d<span class="token punctuation">)</span>
    <span class="token function">case</span><span class="token punctuation">(</span>en<span class="token punctuation">)</span>
        <span class="token number">2'b00</span><span class="token punctuation">:</span> mux_out  <span class="token operator">=</span> a<span class="token punctuation">;</span>
        <span class="token number">2'b01</span><span class="token punctuation">:</span> mux_out  <span class="token operator">=</span> b<span class="token punctuation">;</span>
        <span class="token number">2'b10</span><span class="token punctuation">:</span> mux_out  <span class="token operator">=</span> c<span class="token punctuation">;</span>
        <span class="token number">2'b11</span><span class="token punctuation">:</span> mux_out 	<span class="token operator">=</span> d<span class="token punctuation">;</span>
    <span class="token keyword">endcase</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="存储器建模"><a href="#存储器建模" class="headerlink" title="存储器建模"></a>存储器建模</h4><ul>
<li><h6 id="Verilog中的向量"><a href="#Verilog中的向量" class="headerlink" title="Verilog中的向量"></a>Verilog中的向量</h6></li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span> <span class="token comment">//定义了一个八位的wire型数据</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span> <span class="token comment">//和上面的一样 [n-1:0]和[n:1]都可以</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>[n-1:0]和[n:1]代表该数据的位宽</strong>，即该数据有几位。最后跟着的是数据的名字。如果一次定义多个数据，数据名之间用逗号隔开。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> b<span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">//非法，低位在左面了</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token comment">//向量a的最高两位</span>
<span class="token keyword">assign</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// a[0] = b[3], a[1] = b[2], a[2] = b[1], a[3] = b[0]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>向量通过<code>[high:low]</code>或者<code>[low:high]</code>进行说明，【<strong>方括号左边的数总是代表向量的最高有效位，并且在读取时，高位总应该写在范围说明符的左面</strong>】</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> data1<span class="token punctuation">;</span>
<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">255</span><span class="token punctuation">]</span> data2<span class="token punctuation">;</span>
<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">byte</span><span class="token punctuation">;</span>

<span class="token keyword">byte</span> <span class="token operator">=</span> data1<span class="token punctuation">[</span><span class="token number">31</span><span class="token operator">-</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">//从第31位开始，宽度为8位，相当于data1[31:24]</span>
<span class="token keyword">byte</span> <span class="token operator">=</span> data2<span class="token punctuation">[</span><span class="token number">24</span><span class="token operator">+</span><span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//从第24位开始，宽度为8位，相当于data1[24:31]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><code>[&lt;starting_bit&gt;+: width]</code>: 从起始位开始递增，位宽为width</p>
<p><code>[&lt;starting_bit&gt;-: width]</code>: 从起始位开始递减，位宽为width</p>
<ul>
<li><h6 id="Verilog中的数组"><a href="#Verilog中的数组" class="headerlink" title="Verilog中的数组"></a>Verilog中的数组</h6></li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span>   y1 <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// y is an scalar reg array of depth=12, each 1-bit wide</span>
<span class="token keyword">wire</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span> y2 <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">// y is an 8-bit vector net with a depth of 4</span>
<span class="token keyword">reg</span>  <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> y3 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// y is a 2D array rows=2,cols=4 each 8-bit wide</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>不要将数组和向量混淆，向量为一个单独的原件，它的位宽为n, 数组由多个原件组成，其中每个原件的位宽为n或1。</p>
<ul>
<li><h6 id="Verilog-语法中基本的存储单元"><a href="#Verilog-语法中基本的存储单元" class="headerlink" title="Verilog 语法中基本的存储单元"></a>Verilog 语法中基本的存储单元</h6></li>
</ul>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span>msb<span class="token punctuation">:</span>lsb<span class="token punctuation">]</span> MemoryName <span class="token punctuation">[</span>memsize<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// example, 数据位宽为8bit, 64个</span>
<span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> RAM8x64 <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">63</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>error<span class="token punctuation">:</span> <span class="token punctuation">]</span> RAM8x64 <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>error<span class="token punctuation">:</span> <span class="token punctuation">]</span> RAM8x64 <span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用存储单元时，不能直接引用存储器某地址的某比特位值，如想对地址为”32 “的第2bit 和高2bit 的值进行操作，则上面这两种描述都是错误的。正确的操作方法是，先将存储单元赋值给某个寄存器，然后在对该寄存器的某位进行相关操作。</p>
<h4 id="串并转换建模"><a href="#串并转换建模" class="headerlink" title="串并转换建模"></a>串并转换建模</h4><p>可以选用移位寄存器、RAM 等来实现。对于数据量比较小的设计来说，可以使用移位寄存器完成串并转换:对于排列顺序有规定的串并转换，可以用case 语句判断实现:对于复杂的串并转换，还可以用状态机实现。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">]</span> pal_out<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>'rst<span class="token punctuation">)</span>
    	pal_out <span class="token operator">&lt;=</span> <span class="token number">8</span>'bO<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    	pal_out <span class="token operator">&lt;=</span> <span class="token operator">&#123;</span>pal_out<span class="token punctuation">,</span> srl_in<span class="token operator">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="同步与异步复位"><a href="#同步与异步复位" class="headerlink" title="同步与异步复位"></a>同步与异步复位</h4><p>一般来说，逻辑电路的任何一个寄存器、存储器结构和其他逻辑单元都必须要附加复位逻辑电路，以保证电路能够从错误状态中恢复，可靠地工作。常用的复位信号为低电平有效信号，在应用时外部引脚接上拉电阻，这样能增加复位电路的抗干扰性能。</p>
<h5 id="同步复位电路建模"><a href="#同步复位电路建模" class="headerlink" title="同步复位电路建模"></a>同步复位电路建模</h5><p>指定同步复位时， always 的敏感表中仅有时钟沿信号，仅仅当时钟沿采到同步复位的有效电平时，才会在时钟沿到达时刻进行复位操作。如果目标器件或可用库中的触发器本身包含同步复位端口，则在实现同步复位电路时可以直接调用同步复位端。然而很多目标器件(如PLD) 和ASIC 库的触发器本身并不包含同步复位端口，这样复位信号与输入信号组成某种组合逻辑(比如复位低电平有效，只需复位与输入信号两者相与即可) ，然后将其输入到寄存器的输入端。为了提高复位电路的优先级，一般在电路描述时使用带有优先级的if…else 结构，复位电路在第一个if 下描述，其他电路在else 或else…if 分支中描述。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span>
	<span class="token keyword">else</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><img src="/images/image-20210403230835724.png" alt="image-20210403230835724"></p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ul>
<li>使用同步复位可以设计100% 的同步时序电路，有利于时序分析，其综合结果的频率往往较高</li>
<li>同步复位仅在时钟的有效沿生效，可以有效地避免因复位电路毛刺造成的亚稳态和错误.同步复位在进行复位和释放复位信号时，都是仅当时钟沿采到复位信号电平变化时才进行相关操作，如果复位信号树的组合逻辑出现了某种毛刺，此时时钟沿采样到毛刺的概率非常低，这样通过时钟沿采样，可以十分有效地过滤复位电路组合逻辑产生的毛刺，增强了电路稳定性.</li>
</ul>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>很多目标器件(FPGA) 和ASIC 库的触发器本身并不包含同步复位端口，使用同步复位会增加更多逻辑资源</li>
<li>同步复位的最大问题在于必须保证复位信号的有效时间足够长，这样才能保证所有触发器都能有效地复位。设计中还要考虑到同步复位信号树通过所有相关组合逻辑路径时的延时，以及由于时钟布线产生的skew。这样，只有同步复位大于时钟最大周期，加上同步信号穿过的组合逻辑路径延时，再加上时钟偏斜时，才能保证同步复位可靠、彻底。</li>
</ul>
<img src="/images/image-20210403231427761.png" alt="image-20210403231427761" style="zoom: 80%;" />

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Tsyn_rst &gt; Period_max + (clk2 - clk1) + t1 + t2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="异步复位电路建模"><a href="#异步复位电路建模" class="headerlink" title="异步复位电路建模"></a>异步复位电路建模</h5><p>指定异步复位时，只需在always 的敏感表中加入复位信号的有效沿即可，当复位信号有效沿到达时，无论时钟沿是否有效，复位都会立即发挥其功能。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> rst<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rst<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span>
	<span class="token keyword">else</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>大多数目标器件(如FPGA 和CPLD) 和ASIC 库的触发器都包含异步复位端口，异步复位会被直接接到触发器的异步复位端口。</li>
</ul>
<p><img src="/images/image-20210403232020963.png" alt="image-20210403232020963"></p>
<h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul>
<li>对于大多数FPGA ，都有专用的全局异步复位/置位资源(GSR， Global SetReset )，使用GSR 资源，异步复位到达所有寄存器的偏斜(skew) 最小。</li>
<li>异步复位设计简单，节约资源。</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>异步复位的作用和释放与时钟沿没有直接关系，异步复位生效时问题并不明显;但是当释放异步复位时，如果异步复位信号释放时间和时钟的有效沿到达时间几乎一致，则容易造成触发器输出为亚稳态，形成逻辑错误。</li>
<li>如果异步复位逻辑树的组合逻辑产生了毛刺，则毛刺的有效沿会使触发器误复位，造成逻辑错误。</li>
</ul>
<h5 id="推荐的复位方式"><a href="#推荐的复位方式" class="headerlink" title="推荐的复位方式"></a>推荐的复位方式</h5><p>推荐的复位电路设计方式是异步复位、同步释放。这种方式，可以有效地继承异步复位设计简单的优势，并克服异步复位的上述风险与缺陷。异步复位，同步释放的设计方法有很多，关键是如何保证同步地释放复位信号。</p>
<pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">reg</span> reset_reg<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk<span class="token punctuation">)</span>
	reset_reg <span class="token operator">&lt;=</span> rst<span class="token punctuation">;</span>
<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> reset <span class="token keyword">reg</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>reset_reg<span class="token punctuation">)</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span>
	<span class="token keyword">else</span> <span class="token keyword">begin</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">end</span>
<span class="token comment">//本例使用时钟将外部输入的异步复位信号寄存一个节拍后，再送到触发器异步复位端口</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="/images/image-20210403233242182.png" alt="image-20210403233242182"></p>
<h2 id="常用设计技巧"><a href="#常用设计技巧" class="headerlink" title="常用设计技巧"></a>常用设计技巧</h2><h3 id="同步设计与多时钟处理"><a href="#同步设计与多时钟处理" class="headerlink" title="同步设计与多时钟处理"></a>同步设计与多时钟处理</h3><h4 id="亚稳态"><a href="#亚稳态" class="headerlink" title="亚稳态"></a>亚稳态</h4><p>异步时钟域数据转换的核心就是要保证下一级时钟对上级数据来样的Setup 时间和Hold时间。如果触发器的Setup 时间或者Hold 时间不能得到满足，则有可能会产生亚稳态，此时触发器输出端Q 在有效时钟沿到达之后比较长的一段时间内将处于不确定的状态。在这段时间内Q 端将会产生毛刺并不断振荡，最终固定在某一电压值上，此电压值并不一定等于原来数据输入端D 的数值，这段时间称为决断时间(Resolutíon tíme) 。经过决断时间之后， Q 端将稳定到0或1，但是究竟是0还是1这是随机的，与输入没有必然的关系。</p>
<img src="/images/image-20210404140858203.png" alt="image-20210404140858203" style="zoom: 80%;" />

<ul>
<li>使用两级以上寄存器采样可以有效地降低亚稳态继续传播的概率。其原理是即使第一个触发器的输出端存在亚稳态，但经过→个Clk 周期后，第二个触发器D 端的电平仍未稳定的概率会非常小，因此第二个触发器Q 端基本不会产生亚稳态。如果再添加一级寄存器，使同步采样达到3 级，则末级输出为亚稳态的概率几乎为0 。</li>
<li>使用如图 所示的两级寄存器采样仅能降低亚稳态的概率，但是并不能保证第三级输出的稳态电平就是正确电平。前面说过，经过决断时间之后，寄存器输出的电平是一个不确定的稳态值，也就是说这种处理方法并不能排除采样错误的产生，这时就要求所设计的系统对采样错误要有一定的容忍度。</li>
</ul>
<img src="/images/image-20210404140946263.png" alt="image-20210404140946263" style="zoom:80%;" />

<h4 id="异步时钟域同步"><a href="#异步时钟域同步" class="headerlink" title="异步时钟域同步"></a>异步时钟域同步</h4><ul>
<li><p>两个域的时钟频率相同，但是相位差不固定，或者相位差固定，但是不可测，简称为同频异相问题</p>
</li>
<li><p>两个时钟域频率不同，简称为异频问题</p>
</li>
</ul>
<h5 id="同频异相"><a href="#同频异相" class="headerlink" title="同频异相"></a>同频异相</h5><p>同频异相问题的简单解决方法是用后级时钟对前级数据采样两次，即通常所述的用寄存器打两次这种做法可以有效地减少亚稳态的传播，使后级电路数据都是有效电平值。但是这种做法并不能保证两级寄存器采样后的数据是正确的电平值，因为一旦Setup 或Hold 时间不满足，采样发生亚稳态，则经决断时间后，还是可能判决到错误的电值</p>
<img src="/images/image-20210404142036228.png" alt="image-20210404142036228" style="zoom:80%;" />

<h5 id="异频问题"><a href="#异频问题" class="headerlink" title="异频问题"></a>异频问题</h5><p>解决异频问题的可靠方法就是使用DPRAM 或FIFO。用上级随路时钟写入上级数据，然后用本级时钟读出数据。但是由于时钟频率不同，所以两个端口的数据吞吐率不一致，设计时一定要开好缓冲区，并通过监控( Full 、Half、Empty 等指示)确保数据流不会溢出。</p>
<h3 id="模块划分原则"><a href="#模块划分原则" class="headerlink" title="模块划分原则"></a>模块划分原则</h3><ul>
<li>对每个同步时序设计的子模块的输出使用寄存器(Registering) 。</li>
<li>将相关的逻辑或者可以复用的逻辑划分在同一模块内。</li>
<li>将不同优化目标的逻辑分开。</li>
<li>将时序约束较松的逻辑归入同一模块。</li>
<li>将存储逻辑独立划分成模块。</li>
<li>合适的模块规模。</li>
</ul>
<h3 id="组合逻辑设计注意事项"><a href="#组合逻辑设计注意事项" class="headerlink" title="组合逻辑设计注意事项"></a>组合逻辑设计注意事项</h3><h4 id="always-组合逻辅信号敏感表"><a href="#always-组合逻辅信号敏感表" class="headerlink" title="always 组合逻辅信号敏感表"></a>always 组合逻辅信号敏感表</h4><ul>
<li>正确的信号敏感表设计方法是将always 模块中使用到的所有输入信号和条件判断信号都列在信号敏感表中。</li>
<li>希望通过信号敏感表的增减完成某项逻辑功能是大错特错的。</li>
<li>不完整的信号敏感表有时会造成综合前的仿真结果与综合后仿真、布局布线后仿真的结果不一致。</li>
</ul>
<p>增减信号敏感表后得到的综合结果其实是完全-致的。之所以在增减信号敏感表后得到不同的仿真结果，是因为仿真器的工作机制所致，大多数仿真器是由数据流和时钟周期驱动的，如果信号敏感表中没有某个信号，则无法触发和该信号相关的仿真进程，从而得到不同的仿真结果。</p>
<h4 id="组合逻辑反馈环路"><a href="#组合逻辑反馈环路" class="headerlink" title="组合逻辑反馈环路"></a>组合逻辑反馈环路</h4><p>组合逻辑反馈环路是数字同步逻辑设计的大忌，它最容易因振荡、毛刺、时序违规等问题引起整个系统的不稳定和不可靠。如果Q 输出为0 ，经组合逻辑运算后为异步复位端有效，则电路将会进入不断清零的死循环。</p>
<p><img src="/images/image-20210404143752528.png" alt="image-20210404143752528"></p>
<ul>
<li>牢记任何反馈环路必须包含寄存器。</li>
<li>检查综合、实现报告的Warning 信息，发现Combinational Loops 后立即进行相应的修改。</li>
<li>组合反馈环的逻辑功能完全依赖于其反馈环路上组合逻辑的门延时和布线延时等，如果这些传播延时有任何改变，则该组合反馈环单元的整体逻辑功能将彻底改变，而且改变后的逻辑功能很难确定。</li>
</ul>
<h4 id="脉冲产生器"><a href="#脉冲产生器" class="headerlink" title="脉冲产生器"></a>脉冲产生器</h4><p>常用的同步脉冲产生方法如图所示。该设计的脉冲宽度不因器件改变或设计移植而改变，恒等于时钟周期，避免了异步设计的诸多不确定因素，其时序路径便于计算、STA分析和仿真验证。</p>
<img src="/images/image-20210404144423819.png" alt="image-20210404144423819" style="zoom:80%;" />

<h4 id="逻辑复制"><a href="#逻辑复制" class="headerlink" title="逻辑复制"></a>逻辑复制</h4><p>逻辑复制是一种通过增加面积向改善时序条件的优化手段。逻辑复制最常使用的场合是调整信号的扇出。如果某个信号需要驱动后级的很多单元，换句话说，也就是其扇出非常大，那么为了增加这个信号的驱动能力，就必须插入很多级Buffer ，这样就在一定程度上增加了这个信号路径的延时。这时可以复制生成这个信号的逻辑，用多路同频同相的信号驱动后续电路，使平均到每路的扇出变低，这样不需要插入Buffer 就能满足驱动能力增加的要求，从而节约了该信号的路径延时。</p>
<img src="/images/image-20210404151040411.png" alt="image-20210404151040411" style="zoom:50%;" />

<h4 id="香农扩展运算"><a href="#香农扩展运算" class="headerlink" title="香农扩展运算"></a>香农扩展运算</h4><pre class="line-numbers language-none"><code class="language-none">F(a,b,c) &#x3D; aF(1,b,c) + bar(a)F(0,b,c)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>香农扩展相当于逻辑复制，提高频率:向卡诺逻辑化简相当于资源共享，节约面积。香农扩展通过增加MUX 来缩短某个优先级高、但是组合路径长的信号的路径延时，从而提高了该关键路径的工作频率，这里a为关键路径信号，延时最大。</p>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h3 id="基本要素及分类"><a href="#基本要素及分类" class="headerlink" title="基本要素及分类"></a>基本要素及分类</h3><p>状态机的基本要素有3 个，分别是状态、输出和输入：</p>
<ul>
<li><strong>状态</strong>: 也叫状态变量。在逻辑设计中，使用状态划分逻辑顺序和时序规律。比如设计伪随机码发生器时，可以用移位寄存器序列作为状态;在设计电机控制电路时，可以将电机的不同转速作为状态;在设计通信系统时，可以将信令的状态作为状态变量等。</li>
<li><strong>输出</strong>: 输出指在某一个状态时特定发生的事件。如设计电机控制电路时，如果电机转速过高，则输出为转速过高报警，也可以伴随减速指令或降温措施等。</li>
<li><strong>输入</strong>: 指状态机中进入每个状态的条件，有的状态机没有输入条件，其中的状态转移较为简单，有的状态机有输入条件，当某个输入条件存在时才能转移到相应的状态。</li>
</ul>
<p>根据状态机的输出是否与输入条件相关，可将状态机分为两大类，即Moore型状态机和Mealy型状态机：</p>
<ul>
<li><strong>摩尔型状态机</strong>: 摩尔型状态机的输出仅仅依赖于当前状态，而与输入条件无关。</li>
<li><strong>米勒型状态机</strong>：米勒型状态机的输出不仅依赖于当前状态，而且取决于该状态的输入条件。</li>
</ul>
<h3 id="状态机的不同写法"><a href="#状态机的不同写法" class="headerlink" title="状态机的不同写法"></a>状态机的不同写法</h3><p>这里我 们选用了一个非常典型的摩尔型状态机，共有 4 个状态：IDEL, S1, S2, ERROR；输入信号 为时钟 clk，低电平异步复位信号 nrst，输入信号 i1，i2，输出信号为 o1，o2 和 err，状态关 系如图 6-2 所示。状态的输出下：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>IDLE</td>
<td>{o1,o2,err} = 3’b000;</td>
</tr>
<tr>
<td>S1</td>
<td>{o1,o2,err} = 3’b100;</td>
</tr>
<tr>
<td>S2</td>
<td>{o1,o2,err} = 3’b010;</td>
</tr>
<tr>
<td>ERROR</td>
<td>{o1,o2,err} = 3’b111；</td>
</tr>
</tbody></table>
<img src="/images/image-20210404154959909.png" alt="image-20210404154959909" style="zoom: 67%;" />

<h3 id="两段式写法"><a href="#两段式写法" class="headerlink" title="两段式写法"></a>两段式写法</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token comment">//2-paragraph method to describe FSM</span>
<span class="token comment">//Describe sequential state transition in 1 sequential always block</span>
<span class="token comment">//State transition conditions in the other combinational always block</span>
<span class="token comment">//Package state output by task. Then register the output</span>
<span class="token keyword">module</span> state2 <span class="token punctuation">(</span> nrst<span class="token punctuation">,</span>clk<span class="token punctuation">,</span>i1<span class="token punctuation">,</span>i2<span class="token punctuation">,</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">input</span> nrst<span class="token punctuation">,</span>clk<span class="token punctuation">;</span>
    <span class="token keyword">input</span> i1<span class="token punctuation">,</span>i2<span class="token punctuation">;</span>
    <span class="token keyword">output</span> o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token punctuation">;</span>
    <span class="token keyword">reg</span> o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token punctuation">;</span>
    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> NS<span class="token punctuation">,</span>CS<span class="token punctuation">;</span>
    <span class="token keyword">parameter</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">//one hot with zero idle</span>
         IDLE <span class="token operator">=</span> <span class="token number">3'b000</span><span class="token punctuation">,</span>
         S1 <span class="token operator">=</span> <span class="token number">3</span>’b001<span class="token punctuation">,</span>
         S2 <span class="token operator">=</span> <span class="token number">3</span>’b010<span class="token punctuation">,</span>
         ERROR <span class="token operator">=</span> <span class="token number">3</span>’b100<span class="token punctuation">;</span>
    
    <span class="token comment">//sequential state transition</span>
    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>
         	CS <span class="token operator">&lt;=</span> IDLE<span class="token punctuation">;</span>
         <span class="token keyword">else</span>
         	CS <span class="token operator">&lt;=</span> NS<span class="token punctuation">;</span> 
    <span class="token comment">//combinational condition judgment</span>
	<span class="token important">always @</span> <span class="token punctuation">(</span>CS <span class="token keyword">or</span> i1 <span class="token keyword">or</span> i2<span class="token punctuation">)</span>
		<span class="token keyword">begin</span>
             NS <span class="token operator">=</span> <span class="token number">3'bx</span><span class="token punctuation">;</span>
             ERROR_out<span class="token punctuation">;</span>
             <span class="token keyword">case</span> <span class="token punctuation">(</span>CS<span class="token punctuation">)</span>
                 IDLE<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     IDLE_out<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&amp;&amp;</span> i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> S1<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&amp;&amp;</span> <span class="token operator">~</span>i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
                 S1<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     S1_out<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> S1<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i2 <span class="token operator">&amp;&amp;</span> i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> S2<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i2 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span><span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
                 S2<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     S2_out<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> S2<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i2 <span class="token operator">&amp;&amp;</span> i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i2 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span><span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
                 ERROR<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     ERROR_out<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
             <span class="token keyword">endcase</span>
        <span class="token keyword">end</span>
    
    <span class="token comment">//output task</span>
    <span class="token keyword">task</span> IDLE_out<span class="token punctuation">;</span>
     	<span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;</span> <span class="token operator">=</span> <span class="token number">3'b000</span><span class="token punctuation">;</span>
    <span class="token keyword">endtask</span>
    <span class="token keyword">task</span> S1_out<span class="token punctuation">;</span>
     	<span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;</span> <span class="token operator">=</span> <span class="token number">3'b100</span><span class="token punctuation">;</span>
    <span class="token keyword">endtask</span>
    <span class="token keyword">task</span> S2_out<span class="token punctuation">;</span>
    	<span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;</span> <span class="token operator">=</span> <span class="token number">3'b010</span><span class="token punctuation">;</span>
    <span class="token keyword">endtask</span>
    <span class="token keyword">task</span> ERROR_out<span class="token punctuation">;</span>
     	<span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;</span> <span class="token operator">=</span> <span class="token number">3'b111</span><span class="token punctuation">;</span>
    <span class="token keyword">endtask</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>两段式 FSM 的核心就是：一个 always 模块采用同步时序描述状态转移；另一个模块采用组合逻辑判断状态转移条件，描述状态转移规律。</p>
<ul>
<li><p>一般来说，在这个组合 always 敏感表下先写一个默认的下一状态“NS”的描述，然后 根据实际的状态转移条件由内部的 case 或者 if…else 条件判断确定正确的转移。</p>
</li>
<li><p>推荐在敏感表下的默认状态为不定状态 X，这样描述的好处有两个：第一在仿真时可以 很好的考察所设计的 FSM 的完备性，如果所设计的 FSM 不完备，则会进入任意状态，仿真 很容易发现；第二个好处是综合器对不定态 X 的处理是“Don’t Care”，即任何没有定义的 状态寄存器向量都会被忽略。</p>
</li>
<li><p>对于每个输出，一般用组合逻辑描述，比较简便的方法是用 task/endtask 将输出封装起 来，这样做的好处不仅仅是写法简单，而且利于复用共同的输出。例如本例中 S1 状态的输 出被封装为 S1_out，在组合逻辑 always 模块中直接调用即可。</p>
</li>
</ul>
<img src="/images/image-20210404161258410.png" alt="image-20210404161258410" style="zoom:80%;" />

<h3 id="三段式写法"><a href="#三段式写法" class="headerlink" title="三段式写法"></a>三段式写法</h3><pre class="line-numbers language-verilog" data-language="verilog"><code class="language-verilog"><span class="token keyword">module</span> state3 <span class="token punctuation">(</span> nrst<span class="token punctuation">,</span>clk<span class="token punctuation">,</span>i1<span class="token punctuation">,</span>i2<span class="token punctuation">,</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">input</span> nrst<span class="token punctuation">,</span>clk<span class="token punctuation">;</span>
    <span class="token keyword">input</span> i1<span class="token punctuation">,</span>i2<span class="token punctuation">;</span>
    <span class="token keyword">output</span> o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token punctuation">;</span>
    <span class="token keyword">reg</span> o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token punctuation">;</span>
    <span class="token keyword">reg</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> NS<span class="token punctuation">,</span>CS<span class="token punctuation">;</span>
    <span class="token keyword">parameter</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment">//one hot with zero idle</span>
         IDLE <span class="token operator">=</span> <span class="token number">3'b000</span><span class="token punctuation">,</span>
         S1 <span class="token operator">=</span> <span class="token number">3</span>’b001<span class="token punctuation">,</span>
         S2 <span class="token operator">=</span> <span class="token number">3</span>’b010<span class="token punctuation">,</span>
         ERROR <span class="token operator">=</span> <span class="token number">3</span>’b100<span class="token punctuation">;</span>
    
    <span class="token comment">//sequential state transition</span>
    <span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>
         	CS <span class="token operator">&lt;=</span> IDLE<span class="token punctuation">;</span>
         <span class="token keyword">else</span>
         	CS <span class="token operator">&lt;=</span> NS<span class="token punctuation">;</span> 
    <span class="token comment">//combinational condition judgment</span>
    <span class="token important">always @</span> <span class="token punctuation">(</span>nrst <span class="token keyword">or</span> CS <span class="token keyword">or</span> i1 <span class="token keyword">or</span> i2<span class="token punctuation">)</span>
		<span class="token keyword">begin</span>
             NS <span class="token operator">=</span> <span class="token number">3'bx</span><span class="token punctuation">;</span>
             <span class="token keyword">case</span> <span class="token punctuation">(</span>CS<span class="token punctuation">)</span>
                 IDLE<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&amp;&amp;</span> i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> S1<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i1 <span class="token operator">&amp;&amp;</span> <span class="token operator">~</span>i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
                 S1<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> S1<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i2 <span class="token operator">&amp;&amp;</span> i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> S2<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i2 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span><span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
                 S2<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i2<span class="token punctuation">)</span> NS <span class="token operator">=</span> S2<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i2 <span class="token operator">&amp;&amp;</span> i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i2 <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span><span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
                 ERROR<span class="token punctuation">:</span> <span class="token keyword">begin</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span>i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> ERROR<span class="token punctuation">;</span>
                     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">~</span>i1<span class="token punctuation">)</span> NS <span class="token operator">=</span> IDLE<span class="token punctuation">;</span>
                 <span class="token keyword">end</span>
             <span class="token keyword">endcase</span>
        <span class="token keyword">end</span>
    
    <span class="token comment">//3rd always block, the sequential FSM output</span>
	<span class="token important">always @</span> <span class="token punctuation">(</span><span class="token keyword">posedge</span> clk <span class="token keyword">or</span> <span class="token keyword">negedge</span> nrst<span class="token punctuation">)</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nrst<span class="token punctuation">)</span>
         	 <span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;</span> <span class="token operator">&lt;=</span> <span class="token number">3'b000</span><span class="token punctuation">;</span>
         <span class="token keyword">else</span> <span class="token keyword">begin</span>
             <span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;</span> <span class="token operator">&lt;=</span> <span class="token number">3'b000</span><span class="token punctuation">;</span>
             <span class="token keyword">case</span> <span class="token punctuation">(</span>NS<span class="token punctuation">)</span>
                 IDLE<span class="token punctuation">:</span> <span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;&lt;=</span><span class="token number">3'b000</span><span class="token punctuation">;</span>
                 S1<span class="token punctuation">:</span> <span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;&lt;=</span><span class="token number">3'b100</span><span class="token punctuation">;</span>
                 S2<span class="token punctuation">:</span> <span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;&lt;=</span><span class="token number">3'b010</span><span class="token punctuation">;</span>
                 ERROR<span class="token punctuation">:</span> <span class="token operator">&#123;</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">,</span>err<span class="token operator">&#125;&lt;=</span><span class="token number">3'b111</span><span class="token punctuation">;</span>
             <span class="token keyword">endcase</span>
    	 <span class="token keyword">end</span>
<span class="token keyword">endmodule</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<img src="/images/image-20210404162716395.png" alt="image-20210404162716395" style="zoom:80%;" />

<p>三段式与两段式 FSM 描述的最大区别在于两段式采用了组合逻辑输出，而三段式巧妙地根据下一状态的判断，用同步时序逻 辑寄存 FSM 的输出。另一方面，三段式描述方法与两段式描述相比，虽然代码结构复杂了一些，但是换来的 优势是使 FSM 做到了同步寄存器输出，消除了组合逻辑输出的不稳定与毛刺的隐患，而且 更利于时序路径分组，一般来说在 FPGA/CPLD 等可编程逻辑器件上的综合与布局布线效果 更佳。</p>
<h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><h4 id="FSM编码"><a href="#FSM编码" class="headerlink" title="FSM编码"></a>FSM编码</h4><p>Binary（二进制编码）、gray-code（格雷码）编码使用最少的触发器，较多 的组合逻辑，而 one-hot（独热码）编码反之。one-hot 编码的最大优势在于状 态比较时仅仅需要比较一个 bit，一定程度上从而简化了比较逻辑，减少了毛 刺产生的概率。由于 CPLD 更多地提供组合逻辑资源，而 FPGA 更多地提供触 发器资源，所以 CPLD 多使用 gray-code，而 FPGA 多使用 one-hot 编码。另一 方面，对于小型设计使用 gray-code 和 binary 编码更有效，而大型状态机使用 one-hot 更高效。</p>
<h4 id="FSM-输出"><a href="#FSM-输出" class="headerlink" title="FSM 输出"></a>FSM 输出</h4><p>如果使用 2 段式 FSM 描述 Mealy 状态机，输出逻辑可以用”？语句”描述，或 者使用 case 语句判断转移条件与输入信号即可。如果输出条件比较复杂，而且 多个状态共用某些输出，则建议使用 task/endtask 将输出封装起来，达到模块 复用的目的。</p>
<h4 id="FSM-的默认状态"><a href="#FSM-的默认状态" class="headerlink" title="FSM 的默认状态"></a>FSM 的默认状态</h4><p>完整的状态机应该包含一个默认( defauIt)状态，当转移条件不满足或者状态发生突变时，要能保证逻辑不会陷入”死循环”这是对状态机健壮性的一个重要要求，也就是常说的要具备”自恢复”功能。对应于编码上就是对case 和if…else 语句要特别注意，尽量使用完备的条件判断语句。Verilog 中，使用case 语句的时候要用defauIt建立默认状态。其实我们可以将其中一个状态不编码，指定其为default 默认状态，则任何与所列状态机不匹配的状态都会转到default 状态，从而增强了FSM 的健壮性，另外也可以添加一个额外的default 状态，电路一旦运行到这个状态，就会自动跳转到IDLE 状态，从新启动状态机，这样做也能增强状态机的健壮性。</p>
<p><img src="/images/image-20210404165317971.png" alt="image-20210404165317971"></p>
<p><strong>Testbench的编写，todo</strong></p>
]]></content>
      <categories>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>AXI Bus</title>
    <url>/2021/04/14/axi-bus/</url>
    <content><![CDATA[<h2 id="AXI4-Protocol"><a href="#AXI4-Protocol" class="headerlink" title="AXI4 Protocol"></a>AXI4 Protocol</h2><p><strong>A detour to learn the interface generation phase of HLS</strong> <strong>(Adapt to Xilinx FPGA)</strong></p>
<p>The AXI protocol is burst-based and defines the following independent transaction channels</p>
<ul>
<li>read address</li>
<li>read data</li>
<li> write address</li>
<li>write data</li>
<li>write response.</li>
</ul>
<img src="/images/image-20210410102209585.png" alt="image-20210410102209585" style="zoom:50%;" />

<span id="more"></span>

<img src="/images/image-20210410102236545.png" alt="image-20210410102236545" style="zoom:50%;" />

<p>Each of the independent channels consists of a set of information signals and VALID and READY signals that provide a <strong>two-way handshake</strong> mechanism. The information source uses the VALID signal to show when valid address, data or control information is availableon the channel. The destination uses the READY signal to show when it can accept the information. Both the readdata channel and the write data channel also include a LAST signal to indicate the transfer of the final data item in a transaction</p>
<h3 id="Handshake-Process"><a href="#Handshake-Process" class="headerlink" title="Handshake Process"></a>Handshake Process</h3><p>All five transaction channels use the same VALID/READY handshake process to transfer address, data, and control information.</p>
<ul>
<li>The source generates the <strong>VALID</strong> signal to indicate when the address, data or control information is available.</li>
<li>The destination generates the <strong>READY</strong> signal to indicate that it can accept the information.</li>
<li>Transfer occurs only when both the <strong>VALID</strong> and <strong>READY</strong> signals are HIGH.</li>
</ul>
<img src="/images/image-20210410121242174.png" alt="image-20210410121242174" style="zoom: 67%;" />

<h3 id="Signal-Descriptions"><a href="#Signal-Descriptions" class="headerlink" title="Signal Descriptions"></a>Signal Descriptions</h3><h4 id="Global-Signals"><a href="#Global-Signals" class="headerlink" title="Global Signals"></a>Global Signals</h4><p><img src="/images/image-20210410103513352.png" alt="image-20210410103513352"></p>
<ul>
<li><strong>CLK</strong>: All signals are sampled on the rising edge of the global clock. Each AXI component uses a single clock signal, ACLK. All input signals are sampled on the rising edge of ACLK. All output signal changes must occur after the rising edge of ACLK.</li>
<li><strong>RST</strong>: The AXI protocol uses a single active LOW reset signal, ARESETn. The reset signal can be asserted asynchronously.During reset the following interface requirements apply: a master  interface must drive ARVALID, AWVALID, and WVALID LOW; a slave interface must drive RVALID and BVALID LOW.</li>
</ul>
<h4 id="Write-address-channel-signals"><a href="#Write-address-channel-signals" class="headerlink" title="Write address channel signals"></a>Write address channel signals</h4><p><img src="/images/image-20210410104054317.png" alt="image-20210410104054317"></p>
<h4 id="Write-data-channel-signals"><a href="#Write-data-channel-signals" class="headerlink" title="Write data channel signals"></a>Write data channel signals</h4><p><img src="/images/image-20210410104207295.png" alt="image-20210410104207295"></p>
<h4 id="Write-response-channel-signals"><a href="#Write-response-channel-signals" class="headerlink" title="Write response channel signals"></a>Write response channel signals</h4><p><img src="/images/image-20210410104446621.png" alt="image-20210410104446621"></p>
<h4 id="Read-address-channel-signals"><a href="#Read-address-channel-signals" class="headerlink" title="Read address channel signals"></a>Read address channel signals</h4><p><img src="/images/image-20210410104801188.png" alt="image-20210410104801188"></p>
<h4 id="Read-data-channel-signals"><a href="#Read-data-channel-signals" class="headerlink" title="Read data channel signals"></a>Read data channel signals</h4><p><img src="/images/image-20210410105006758.png" alt="image-20210410105006758"></p>
<h4 id="Burst-W-R"><a href="#Burst-W-R" class="headerlink" title="Burst W/R"></a>Burst W/R</h4><ul>
<li><p><code>Burst_Length = AxLEN[7:0] + 1</code></p>
</li>
<li><p>The maximum number of bytes to transfer in each data transfer, or beat, in a burst, is specified by ARSIZE[2:0], for read transfers, AWSIZE[2:0], for write transfers</p>
</li>
</ul>
<img src="/images/image-20210410123001574.png" alt="image-20210410123001574" style="zoom:50%;" />

<img src="/images/image-20210410124207465.png" alt="image-20210410124207465" style="zoom:80%;" />

<img src="/images/image-20210410124313603.png" alt="image-20210410124313603" style="zoom:80%;" />

<h3 id="AXI-Lite"><a href="#AXI-Lite" class="headerlink" title="AXI-Lite"></a>AXI-Lite</h3><p>The key functionality of AXI4-Lite operation is:</p>
<ul>
<li>all transactions are of burst length 1</li>
<li>all data accesses use the full width of the data bus AXI4-Lite supports a data bus width of 32-bit or 64-bit.</li>
<li>all accesses are Non-modifiable, Non-bufferable</li>
<li>Exclusive accesses are not supported.</li>
</ul>
<p><img src="/images/image-20210410123834687.png" alt="image-20210410123834687"></p>
<h3 id="Xilinx-M-AXI-Adapter-Burst-transaction"><a href="#Xilinx-M-AXI-Adapter-Burst-transaction" class="headerlink" title="Xilinx M-AXI Adapter (Burst transaction)"></a>Xilinx M-AXI Adapter (Burst transaction)</h3><p><img src="/images/image-20210411145937526.png" alt="image-20210411145937526"></p>
<p>When your design makes a read/write request, the request is sent to the DDR through several specialized helper modules. First, the M-AXI adapter serves as a buffer for the requests created by the HLS kernel. The adapter contains logic to cut large bursts into smaller ones (which it needs to do to prevent hogging the channel or if the request crosses the 4 KB boundary, see Vivado Design Suite: AXI Reference Guide (UG1037)), and can also stall the sending of burst requests (depending on the maximum outstanding requests parameter) so that it can safely buffer the entirety of the data for each kernel. This can slightly increase write latency but can resolve deadlock due to concurrent requests (read or write) on the memory subsystem. </p>
]]></content>
      <categories>
        <category>HLS</category>
      </categories>
      <tags>
        <tag>HLS</tag>
      </tags>
  </entry>
</search>
